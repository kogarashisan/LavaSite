{
	type: "widget",
	is_extended: true,
	template: ["<h1 id=\"containers-overview\">Containers overview</h1>\n<p>In Lava framework you never create DOM elements directly, instead framework renders them as text and inserts into\nthe document. This is fast, and what is more important - this allows to provide an abstraction layer \nbetween DOM and framework.</p>\n<p>Framework accesses DOM elements with the help of <i>containers</i> - they are the bridge between views and DOM.\nEach view can have a container, and there are three kinds of them.</p>\n<h2 id=\"element-container\">Element container</h2>\n<p><a href=\"/www/doc.html#class=Lava.view.container.Element\">Lava.view.container.Element</a> container controls a html element, with ability to bind it&#39;s properties,\nstyles and classes to expression results. May be used to delegate events. Rendered DOM element of this container\nalways has auto-generated <code>id</code> attribute, for example:</p>\n<div class=\"lava-code-container\"><div class=\"lava-code\"><pre class=\"lava-code-line-numbers\">&nbsp;&nbsp;1\r\n</pre><pre class=\"lava-code-content hljs xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">div</span> <span class=\"hljs-attribute\">id</span>=<span class=\"hljs-value\">\"e123\"</span>&gt;</span> ... <span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">div</span>&gt;</span></pre></div></div><p>Id is used to retrieve the element from DOM after rendering. \nNumber in the attribute equals to <a href=\"/www/doc.html#class=Lava.view.Abstract;member=guid\">Abstract#guid</a> of container&#39;s view.</p>\n<h2 id=\"morph-container\">Morph container</h2>\n<p><a href=\"/www/doc.html#class=Lava.view.container.Morph\">Lava.view.container.Morph</a> - represents two &lt;script&gt; tags, with content between them.\nThat&#39;s how it looks like in DOM:</p>\n<div class=\"lava-code-container\"><div class=\"lava-code\"><pre class=\"lava-code-line-numbers\">&nbsp;&nbsp;1\r\n2\r\n3\r\n</pre><pre class=\"lava-code-content hljs xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">script</span> <span class=\"hljs-attribute\">id</span>=<span class=\"hljs-value\">'c123s'</span> <span class=\"hljs-attribute\">type</span>=<span class=\"hljs-value\">'x'</span>&gt;</span><span class=\"javascript\"></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">script</span>&gt;</span>\n...\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">script</span> <span class=\"hljs-attribute\">id</span>=<span class=\"hljs-value\">'c123e'</span> <span class=\"hljs-attribute\">type</span>=<span class=\"hljs-value\">'x'</span>&gt;</span><span class=\"javascript\"></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">script</span>&gt;</span></pre></div></div><p><span class=\"api-string\">&quot;s&quot;</span> and <span class=\"api-string\">&quot;e&quot;</span> stand for &quot;start&quot; and &quot;end&quot;.</p>\n<p>Content between script tags can be replaced. Script tags are invisible and inline, \nso this container can be used to replace inline text.\nScript tags can also be inserted where text and markup is not allowed, \nfor example between &lt;table&gt; and &lt;tbody&gt; tags.</p>\n<h2 id=\"emulated-container\">Emulated container</h2>\n<p><a href=\"/www/doc.html#class=Lava.view.container.Emulated\">Lava.view.container.Emulated</a> - virtual, invisible container without actual DOM representation.\nBut, it can use surrounding Element and Morph containers to manipulate DOM.</p>\n<p>For example, you have an If view with Emulated container, which follows a view with an Element container. \nWhen condition of the If view changes from <span class=\"api-keyword\">false</span> to <span class=\"api-keyword\">true</span> - \nEmulated container knows that it can insert view content after the previous element.</p>\n<h2 id=\"container-state\">Container state</h2>\n<p>When you want to render a container - you call <code>wrap(html)</code> - it renders container tags with all attributes\nand wraps <code>html</code> inside them. You must insert the rendered HTML into DOM immediately:\nif manipulate data or refresh bindings - in this case rendered data will become stale,\nand container will not refresh itself properly. After insert, you must call <code>informInDOM()</code> - \nto tell the container, that it&#39;s now in DOM.</p>\n<p>Views and containers have very simple state machine: it does not track the fact that it was rendered,\nand you could render it several times in a row. When Element container knows that it&#39;s in DOM - it will start to refresh it&#39;s property \nbindings, and calls to <a href=\"/www/doc.html#class=Lava.view.container.Element;member=getDOMElement\">Element#getDOMElement</a> will return it&#39;s DOM element.</p>\n<p><b>Before</b> removing container from DOM, you must call <code>informRemove()</code> - this makes the container to forget cached reference\nto it&#39;s DOM element(s) and stops synchronization of bound properties.</p>\n<p>Another state of containers is &quot;sleeping&quot;. It does not affect Morph and Emulated containers, \nbut when Element container receives <code>sleep()</code> command - it suspends it&#39;s bindings.\nWhen container is removed from DOM - it&#39;s automatically suspended.</p>\n<p>Suspended containers can be resumed with call to <code>wakeup()</code>.</p>\n<h2 id=\"element-container-in-depth\">Element container in depth</h2>\n<p>Due to nature of Lava views - they can be re-rendered at any moment. Generally, you should not manually change \nproperties on elements inside Lava views, cause you will lose your changes when they are refreshed. \nAnimation is an exception: it&#39;s performed directly on elements, without access to containers.</p>\n<p>When container is rendered - it renders itself with it&#39;s current properties.\nTo keep your changes in sync - you can use Element container&#39;s API, for example:</p>\n<ul>\n<li><code>setProperty(name, value)</code> - sets a static property to container and sets it on it&#39;s DOM element</li>\n<li><code>storeProperty(name, value)</code> - sets property on container, but does <b>not</b> set it on the DOM element</li>\n<li><code>syncProperty(name)</code> - refreshes the value on DOM element</li>\n</ul>\n<p>Similar methods exists for styles and classes.</p>\n<p>For an example of <code>storeProperty</code> usage - see the framework&#39;s input widgets: they listen to the &quot;changed&quot; event on\n&lt;input&gt; DOM elements, and store new &quot;value&quot; in their container.</p>\n<p>You should know:</p>\n<ul>\n<li>when container is in DOM - property bindings are refreshed immediately when change notification is received</li>\n<li>void tags are always rendered as selfclosing. This is compatible with HTML5 mode, and required prior to HTML5</li>\n<li>attributes with <span class=\"api-keyword\">null</span> and <span class=\"api-keyword\">false</span> values are not rendered. \nWhen an attribute is set to <span class=\"api-keyword\">null</span> - it&#39;s removed from DOM element. You can also return <span class=\"api-keyword\">null</span> \nfrom binding arguments (and <span class=\"api-keyword\">false</span> for boolean attributes) to remove the attribute.</li>\n</ul>\n<p>Boolean <span class=\"api-keyword\">true</span> attributes are rendered in <code>&amp;lt;name&amp;gt;=&quot;&amp;lt;name&amp;gt;&quot;</code> form (for example: <code>checked=&quot;checked&quot;</code>).</p>\n<p><b>Important note on attribute validity</b>: it&#39;s not safe to bind your attributes to user input,\nand it&#39;s your responsibility to check user input to avoid XSS attacks.</p>\n"],
	container: {
		type: "Element",
		tag_name: "div"
	}
}