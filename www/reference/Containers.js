var page_json = {
	type: "widget",
	is_extended: true,
	template: ["<h1 id=\"containers-overview\">Containers overview</h1>\n<p>In Lava framework you never create DOM elements directly, instead framework renders them as text and inserts into\nthe document. This is fast, and what is more important - this allows to provide an abstraction layer \nbetween DOM and framework.</p>\n<p>Framework accesses DOM elements with the help of <i>containers</i> - they are the bridge between views and DOM.\nEach view can have a container, and there are three kinds of them.</p>\n<h2 id=\"element-container\">Element container</h2>\n<p><a href=\"/www/doc/class/Lava.view.container.Element.html\">Lava.view.container.Element</a> container controls a html element, with ability to bind it&#39;s properties,\nstyles and classes to expression results. May be used to delegate events. Rendered DOM element of this container\nalways has auto-generated <code>id</code> attribute, for example:</p>\n<div class=\"lava-new-code-container lava-new-code-container-primary\"><div class=\"lava-new-code-box\"><pre class=\"lava-new-code-line-numbers\">&nbsp;&nbsp;1\r\n</pre><div class=\"lava-new-code-overlays\"><pre class=\"lava-new-code-content hljs xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">div</span> <span class=\"hljs-attribute\">id</span>=<span class=\"hljs-value\">\"e123\"</span>&gt;</span> ... <span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">div</span>&gt;</span></pre></div></div></div><p>Id is used to retrieve the element from DOM after rendering. \nNumber in the attribute equals to <a href=\"/www/doc/class/Lava.view.Abstract.html#member=guid\">Abstract#guid</a> of container&#39;s view.</p>\n<h2 id=\"morph-container\">Morph container</h2>\n<p><a href=\"/www/doc/class/Lava.view.container.Morph.html\">Lava.view.container.Morph</a> - represents two &lt;script&gt; tags, with content between them.\nThat&#39;s how it looks like in DOM:</p>\n<div class=\"lava-new-code-container lava-new-code-container-primary\"><div class=\"lava-new-code-box\"><pre class=\"lava-new-code-line-numbers\">&nbsp;&nbsp;1\r\n2\r\n3\r\n</pre><div class=\"lava-new-code-overlays\"><pre class=\"lava-new-code-content hljs xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">script</span> <span class=\"hljs-attribute\">id</span>=<span class=\"hljs-value\">'c123s'</span> <span class=\"hljs-attribute\">type</span>=<span class=\"hljs-value\">'x'</span>&gt;</span><span class=\"javascript\"></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">script</span>&gt;</span>\n...\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">script</span> <span class=\"hljs-attribute\">id</span>=<span class=\"hljs-value\">'c123e'</span> <span class=\"hljs-attribute\">type</span>=<span class=\"hljs-value\">'x'</span>&gt;</span><span class=\"javascript\"></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">script</span>&gt;</span></pre></div></div></div><p><span class=\"api-string\">&quot;s&quot;</span> and <span class=\"api-string\">&quot;e&quot;</span> stand for &quot;start&quot; and &quot;end&quot;.</p>\n<p>Content between script tags can be replaced. Script tags are invisible and inline, \nso this container can be used to replace inline text.\nScript tags can also be inserted where text and markup is not allowed, \nfor example between &lt;table&gt; and &lt;tbody&gt; tags.</p>\n<h2 id=\"emulated-container\">Emulated container</h2>\n<p><a href=\"/www/doc/class/Lava.view.container.Emulated.html\">Lava.view.container.Emulated</a> - virtual, invisible container without actual DOM representation.\nBut, it can use surrounding Element and Morph containers to manipulate DOM.</p>\n<p>Consider this example: you have an If view with Emulated container, and another view with an Element container before it. \nEmulated container of the If view can be configured to insert it&#39;s content after previous element, \nso when condition of the IF view changes from <span class=\"api-keyword\">false</span> to <span class=\"api-keyword\">true</span> - \nit will be able to perform refresh on it&#39;s own (without help of it&#39;s parent views).</p>\n<p>Emulated containers are typically used with <a href=\"/www/doc/reference/Refreshers.html\">Refreshers</a>.</p>\n<h2 id=\"container-state\">Container state</h2>\n<p>When you want to render a container - you call <code>wrap(html)</code> - it renders container tags with all attributes\nand wraps <code>html</code> inside them. You must insert the rendered HTML into DOM immediately:\nif you change data or refresh bindings - then rendered data will become stale,\nand container will not refresh itself properly. After insert, you must call <code>informInDOM()</code> - \nto tell the container, that it&#39;s now in DOM.</p>\n<p>Views and containers have very simple state machine: it does not track the fact that it was rendered,\nso they will not notice if you render them several times in a row (<b>but it&#39;s not safe to do that</b>).\nWhen Element container knows that it&#39;s in DOM - it will start to refresh it&#39;s property \nbindings, and calls to <a href=\"/www/doc/class/Lava.view.container.Element.html#member=getDOMElement\">Element#getDOMElement</a> will return it&#39;s DOM element.</p>\n<p><b>Before</b> removing container from DOM, you must call <code>informRemove()</code> - this makes the container to forget cached reference\nto it&#39;s DOM element(s) and stops synchronization of bound properties.</p>\n<h2 id=\"element-container-in-depth\">Element container in depth</h2>\n<p>Due to nature of Lava views - they can be re-rendered at any moment. Generally, you should not manually change \nproperties on elements inside Lava views, cause you will lose your changes when they are refreshed. \nTo keep your changes in sync - you can use Element container&#39;s API, for example:</p>\n<ul>\n<li><code>setProperty(name, value)</code> - sets a static property to container and sets it on it&#39;s DOM element</li>\n<li><code>storeProperty(name, value)</code> - sets property on container, but does <b>not</b> set it on the DOM element</li>\n<li><code>syncProperty(name)</code> - refreshes the value on DOM element</li>\n</ul>\n<p>Similar methods exists for styles and classes.</p>\n<p>Important things to remember:</p>\n<ul>\n<li>when container is in DOM - property bindings are refreshed immediately when their arguments change</li>\n<li>void tags are always rendered as selfclosing. This is compatible with HTML5 mode, and required prior to HTML5</li>\n<li>attributes with <span class=\"api-keyword\">null</span> and <span class=\"api-keyword\">false</span> values are not rendered. \nWhen an attribute is set to <span class=\"api-keyword\">null</span> - it&#39;s removed from DOM element. You can also return <span class=\"api-keyword\">null</span> \nfrom binding arguments (and <span class=\"api-keyword\">false</span> for boolean attributes) to remove the attribute.</li>\n</ul>\n<p>Boolean <span class=\"api-keyword\">true</span> attributes are rendered in <code>&lt;name&gt;=&quot;&lt;name&gt;&quot;</code> form (for example: <code>checked=&quot;checked&quot;</code>).</p>\n<p><b>Important note on attribute validity</b>: it&#39;s not safe to bind element attributes directly to user input,\nand it&#39;s your responsibility to check user input to avoid XSS attacks.</p>\n"],
	container: {
		type: "Element",
		tag_name: "div"
	}
}