{
	type: "widget",
	is_extended: true,
	template: ["<h1 id=\"collections\">Collections</h1>\n<p>Collection classes are used for data binding. They provide &quot;collection_changed&quot;, &quot;items_added&quot; and &quot;items_removed&quot;\nevents, which are used by views to refresh displayed data.</p>\n<h2 id=\"enumerable\">Enumerable</h2>\n<p><a href=\"/www/doc.html#class=Lava.system.Enumerable\">Lava.system.Enumerable</a> is an array-like collection of objects, but for each value it also generates a UID \n(Unique item ID) and stores &quot;name&quot; - the key of the item, when Enumerable was updated from Properties or an object. </p>\n<p>Internally it has three arrays:</p>\n<div class=\"lava-code-container\"><div class=\"lava-code\"><pre class=\"lava-code-line-numbers\">&nbsp;&nbsp;1\r\n2\r\n3\r\n</pre><pre class=\"lava-code-content hljs javascript\">_data_uids: [],\n_data_values: [],\n_data_names: []</pre></div></div><p>They are gap-less and always of the same length. Each index in these arrays holds corresponding UID, name and value.</p>\n<p>Unique IDs are generated automatically for every new value, which you add into Enumerable.\nPlease note, that they are not <b>globally</b> unique - each Enumerable has it&#39;s own UID counter, which starts from zero.</p>\n<p>All methods that add new values, also have a way to supply their names, for example:</p>\n<div class=\"lava-code-container\"><div class=\"lava-code\"><pre class=\"lava-code-line-numbers\">&nbsp;&nbsp;1\r\n</pre><pre class=\"lava-code-content hljs javascript\">push: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(value, name)</span> {</span> ... }</pre></div></div><p>When <code>name</code> is not supplied - then it&#39;s set to <span class=\"api-keyword\">null</span>.\nWhen you remove a value from Enumerable - corresponding UID and name are also removed.</p>\n<p>You are recommended to have a look at <a href=\"/www/doc.html#class=Lava.system.Enumerable\">Lava.system.Enumerable</a> API to get familiar with this class.\nMost important methods are <code>sort()</code> and <code>filter()</code> - they preserve existing UIDs.</p>\n<h2 id=\"dataviev\">DataViev</h2>\n<p><a href=\"/www/doc.html#class=Lava.system.DataView\">Lava.system.DataView</a> is designed to display a subset of items from existing Enumerable or another DataView instance, \npreserving original item UIDs. Unlike Enumerable, DataView does not have any methods to directly add new items,\nbut it can be refreshed from it&#39;s data source, then filtered and sorted.</p>\n<p>Just like Enumerable, DataView inherits from <a href=\"/www/doc.html#class=Lava.system.CollectionAbstract\">Lava.system.CollectionAbstract</a>,\nand you can use it for data binding.</p>\n<p>Example usage:</p>\n<div class=\"lava-code-container\"><div class=\"lava-code\"><pre class=\"lava-code-line-numbers\">&nbsp;&nbsp;1\r\n2\r\n3\r\n4\r\n5\r\n6\r\n7\r\n8\r\n9\r\n10\r\n</pre><pre class=\"lava-code-content hljs javascript\"><span class=\"hljs-keyword\">var</span> collection = <span class=\"hljs-keyword\">new</span> Lava.system.Enumerable();\ncollection.push(<span class=\"hljs-string\">\"one\"</span>);\n\n<span class=\"hljs-keyword\">var</span> data_view = <span class=\"hljs-keyword\">new</span> Lava.system.DataView(collection);\ndata_view.getUIDs(); <span class=\"hljs-comment\">// [1]</span>\n\ncollection.push(<span class=\"hljs-string\">\"two\"</span>);\ndata_view.refresh();\n\ndata_view.getUIDs(); <span class=\"hljs-comment\">// [1, 2]</span></pre></div></div><h2 id=\"role-of-uids-in-data-binding\">Role of UIDs in data binding</h2>\n<p>Foreach views in templates use Enumerable and DataView to display lists of items. \nPresence of UIDs allows views to track changes in collections and apply animations to added and removed templates.</p>\n"],
	container: {
		type: "Element",
		tag_name: "div"
	}
}