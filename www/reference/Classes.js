{
	type: "widget",
	is_extended: true,
	template: ["<h1 id=\"classes\">Classes</h1>\n<p><i>Update 09.03.15: &quot;polymorphic mode&quot; and &quot;full export&quot; features are deprecated.</i></p>\n<p>ClassManager generates class constructors from class bodies. Generated constructor assigns instance properties \nand calls <code>init()</code>, if it exists. Methods and other shared members are assigned to generated constructor&#39;s prototype.</p>\n<h2 id=\"polymorphism\">Polymorphism</h2>\n<p>Depending on value of <a href=\"/www/doc.html#object=Lava.ClassManager;member=is_monomorphic\">ClassManager#is_monomorphic</a> switch, it can operate in two modes: \nmonomorphic(default) and polymorphic. Polymorphic mode moves all value types from class body to prototype, \nwhile monomorphic assigns them explicitly in constructor.</p>\n<p>Here is an example of a class and generated code:</p>\n<div class=\"lava-new-code-container lava-new-code-container-primary\"><div class=\"lava-new-code-box\"><pre class=\"lava-new-code-line-numbers\">&nbsp;&nbsp;1\r\n2\r\n3\r\n4\r\n5\r\n6\r\n7\r\n8\r\n9\r\n10\r\n11\r\n</pre><div class=\"lava-new-code-overlays\"><pre class=\"lava-new-code-content hljs javascript\">Lava.define(\n<span class=\"hljs-string\">'Lava.user.MyClass'</span>,\n{\n    counter: <span class=\"hljs-number\">0</span>,\n    null_value: <span class=\"hljs-literal\">null</span>,\n    boolean_value: <span class=\"hljs-literal\">false</span>,\n\n    instance_array: [],\n    object: {}\n    init: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span>{</span>}\n});</pre></div></div></div><p>Monomorphic mode will assign all value members in constructor:</p>\n<div class=\"lava-new-code-container lava-new-code-container-primary\"><div class=\"lava-new-code-box\"><pre class=\"lava-new-code-line-numbers\">&nbsp;&nbsp;1\r\n2\r\n3\r\n4\r\n5\r\n6\r\n7\r\n8\r\n9\r\n10\r\n11\r\n</pre><div class=\"lava-new-code-overlays\"><pre class=\"lava-new-code-content hljs javascript\"><span class=\"hljs-comment\">// equivalent generated class in monomorphic mode</span>\nLava.user.MyClass = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> {</span>\n    <span class=\"hljs-keyword\">this</span>.counter = <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-keyword\">this</span>.null_value = <span class=\"hljs-literal\">null</span>;\n    <span class=\"hljs-keyword\">this</span>.boolean_value = <span class=\"hljs-literal\">false</span>;\n\n    <span class=\"hljs-keyword\">this</span>.instance_array = [];\n    <span class=\"hljs-keyword\">this</span>.object = {};\n    <span class=\"hljs-keyword\">this</span>.init.apply(<span class=\"hljs-keyword\">this</span>, <span class=\"hljs-built_in\">arguments</span>);\n};\nLava.user.MyClass.prototype.init = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> {</span>};</pre></div></div></div><p>While polymorphic mode will move them to prototype:</p>\n<div class=\"lava-new-code-container lava-new-code-container-primary\"><div class=\"lava-new-code-box\"><pre class=\"lava-new-code-line-numbers\">&nbsp;&nbsp;1\r\n2\r\n3\r\n4\r\n5\r\n6\r\n7\r\n8\r\n9\r\n10\r\n</pre><div class=\"lava-new-code-overlays\"><pre class=\"lava-new-code-content hljs javascript\"><span class=\"hljs-comment\">// equivalent generated class in polymorphic mode</span>\nLava.user.MyClass = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> {</span>\n    <span class=\"hljs-keyword\">this</span>.instance_array = [];\n    <span class=\"hljs-keyword\">this</span>.object = {};\n    <span class=\"hljs-keyword\">this</span>.init.apply(<span class=\"hljs-keyword\">this</span>, <span class=\"hljs-built_in\">arguments</span>);\n};\nLava.user.MyClass.prototype.counter = <span class=\"hljs-number\">0</span>;\nLava.user.MyClass.prototype.null_value = <span class=\"hljs-literal\">null</span>;\nLava.user.MyClass.prototype.boolean_value = <span class=\"hljs-literal\">false</span>;\nLava.user.MyClass.prototype.init = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> {</span>};</pre></div></div></div><p>Monomorphic constructors are a bit slower, but they produce class instances with same internal type.\nThis means, that method calls to monomorphic class instances will be faster, then calls to polymorphic ones \n(due to internal optimizations of JavaScript engines). With monomorphic classes your page may take a bit slower to load,\nbut overall performance will be better, so it&#39;s recommended to leave <code>is_monomorphic</code> switch on.</p>\n<p>This switch is individual for each class, so you can change it dynamically before calling <a href=\"/www/doc.html#object=Lava.ClassManager;member=define\">ClassManager#define</a>.</p>\n<p><i>To understand polymorphism better, you are recommended to search for various &quot;V8 optimization&quot; articles.</i></p>\n<h2 id=\"class-structure\">Class structure</h2>\n<p>Functions and <b>RegExp</b> objects are always assigned to prototype and are shared for all class instances.\nIf you want to have different instances of RegExp objects for each class instance - then you can assign it in constructor.</p>\n<p>Value types can also be safely moved to prototype, cause they are never assigned by reference\n(this includes strings, nulls, booleans and numbers). In polymorphic mode they are served from prototype,\nin monomorphic mode they are assigned in constructor.</p>\n<p>Arrays and objects are not shared by default - arrays are sliced, and objects are recursively copied:</p>\n<div class=\"lava-new-code-container lava-new-code-container-primary\"><div class=\"lava-new-code-box\"><pre class=\"lava-new-code-line-numbers\">&nbsp;&nbsp;1\r\n2\r\n3\r\n4\r\n5\r\n6\r\n7\r\n8\r\n9\r\n</pre><div class=\"lava-new-code-overlays\"><pre class=\"lava-new-code-content hljs javascript\">Lava.define(\n<span class=\"hljs-string\">'Lava.user.MyClass'</span>,\n{\n    array: [{test: <span class=\"hljs-literal\">true</span>}],\n    object: {\n        function_property: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> {</span>},\n        array_property: [{test: <span class=\"hljs-literal\">true</span>}]\n    }\n});</pre></div></div></div><p>Generated equivalent:</p>\n<div class=\"lava-new-code-container lava-new-code-container-primary\"><div class=\"lava-new-code-box\"><pre class=\"lava-new-code-line-numbers\">&nbsp;&nbsp;1\r\n2\r\n3\r\n4\r\n5\r\n6\r\n7\r\n8\r\n</pre><div class=\"lava-new-code-overlays\"><pre class=\"lava-new-code-content hljs javascript\">Lava.user.MyClass = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> {</span>\n    <span class=\"hljs-keyword\">var</span> r = <span class=\"hljs-keyword\">this</span>.Class.references;\n    <span class=\"hljs-keyword\">this</span>.array = r[<span class=\"hljs-number\">0</span>].slice();\n    <span class=\"hljs-keyword\">this</span>.object = {\n        function_property: r[<span class=\"hljs-number\">1</span>],\n        array_property: r[<span class=\"hljs-number\">2</span>].slice()\n    }\n}</pre></div></div></div><p>Before class is constructed - all complex arrays and methods from objects are collected into <code>Class.references</code> array,\nso they can be referenced in constructor.</p>\n<p>The fact, that arrays are sliced from original, means that objects inside arrays will be shared across all class instances \n(see <code>{test: true}</code> objects in the example above). If you need to deep copy an array with objects - you should do it\nin constructor.</p>\n<h2 id=\"inherited-methods\">Inherited methods</h2>\n<p>Method overriding happens with the following algorithm: </p>\n<ol>\n<li>First, methods from parent class are copied into child&#39;s prototype</li>\n<li>Then methods from child body are merged into it&#39;s prototype, but if a method with the same name already exists - \nold method is renamed (parent&#39;s name with dollar-sign are prepended to it)</li>\n</ol>\n<p>Note: actual implementation significantly differs, but result is equivalent to the algorithm above.\nHere is an example of method overriding:</p>\n<div class=\"lava-new-code-container lava-new-code-container-primary\"><div class=\"lava-new-code-box\"><pre class=\"lava-new-code-line-numbers\">&nbsp;&nbsp;1\r\n2\r\n3\r\n4\r\n5\r\n6\r\n7\r\n8\r\n9\r\n10\r\n</pre><div class=\"lava-new-code-overlays\"><pre class=\"lava-new-code-content hljs javascript\">Lava.define(<span class=\"hljs-string\">'Lava.user.MyClass'</span>, {\n    init: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(name)</span> {</span> console.log(<span class=\"hljs-string\">\"Hello \"</span> + name); }\n});\n\nLava.define(<span class=\"hljs-string\">'Lava.user.InheritedClass'</span>, {\n    Extends: <span class=\"hljs-string\">'Lava.user.MyClass'</span>,\n    init: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(name)</span> {</span>\n        <span class=\"hljs-keyword\">this</span>.MyClass$init(name);\n    }\n});</pre></div></div></div><p>Equivalent code:</p>\n<div class=\"lava-new-code-container lava-new-code-container-primary\"><div class=\"lava-new-code-box\"><pre class=\"lava-new-code-line-numbers\">&nbsp;&nbsp;1\r\n2\r\n3\r\n4\r\n5\r\n6\r\n7\r\n8\r\n9\r\n10\r\n11\r\n12\r\n13\r\n</pre><div class=\"lava-new-code-overlays\"><pre class=\"lava-new-code-content hljs javascript\">Lava.user.MyClass = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> {</span>\n    <span class=\"hljs-keyword\">this</span>.init.apply(<span class=\"hljs-keyword\">this</span>, <span class=\"hljs-built_in\">arguments</span>);\n}\nLava.user.MyClass.prototype.init = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(name)</span> {</span> console.log(<span class=\"hljs-string\">\"Hello \"</span> + name); }\n\nLava.user.InheritedClass = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> {</span>\n    <span class=\"hljs-keyword\">this</span>.init.apply(<span class=\"hljs-keyword\">this</span>, <span class=\"hljs-built_in\">arguments</span>);\n}\n<span class=\"hljs-comment\">// rename parent's init() in child's prototype</span>\nLava.user.InheritedClass.prototype.MyClass$init = Lava.user.MyClass.prototype.init;\nLava.user.InheritedClass.prototype.init = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(name)</span> {</span>\n    <span class=\"hljs-keyword\">this</span>.MyClass$init(name);\n}</pre></div></div></div><h2 id=\"root-namespaces\">Root namespaces</h2>\n<p>Before you can use ClassManager - you must register root namespaces with a call to\n<a href=\"/www/doc.html#object=Lava.ClassManager;member=registerRootNamespace\">ClassManager#registerRootNamespace</a>. Lava registers itself in <a href=\"/www/doc.html#object=Lava;member=init\">Lava#init</a>, this makes possible to\ncreate classes with paths starting with &quot;Lava.&quot;.</p>\n<p>If you want to create global classes - you could register <span class=\"api-var\">window</span> as a root.\nAll class paths must start with name of a root namespace:</p>\n<div class=\"lava-new-code-container lava-new-code-container-primary\"><div class=\"lava-new-code-box\"><pre class=\"lava-new-code-line-numbers\">&nbsp;&nbsp;1\r\n2\r\n3\r\n4\r\n</pre><div class=\"lava-new-code-overlays\"><pre class=\"lava-new-code-content hljs javascript\">Lava.ClassManager.registerRootNamespace(<span class=\"hljs-string\">'global'</span>, window);\nLava.ClassManager.define(<span class=\"hljs-string\">'global.MyClass'</span>, {<span class=\"hljs-comment\">/*...*/</span>});\n<span class=\"hljs-comment\">// paths can contain other namespaces</span>\nLava.ClassManager.define(<span class=\"hljs-string\">'global.MyLibrary.MyClass'</span>, {<span class=\"hljs-comment\">/*...*/</span>});</pre></div></div></div><p>If intermediate namespace does not exist at the moment of definition - then it&#39;s created as empty object.\nEquivalent code for the above example:</p>\n<div class=\"lava-new-code-container lava-new-code-container-primary\"><div class=\"lava-new-code-box\"><pre class=\"lava-new-code-line-numbers\">&nbsp;&nbsp;1\r\n2\r\n</pre><div class=\"lava-new-code-overlays\"><pre class=\"lava-new-code-content hljs javascript\">window.MyLibrary = {}\nwindow.MyLibrary.MyClass = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> {</span> <span class=\"hljs-comment\">/*...*/</span> }</pre></div></div></div><p><i>Standalone ClassManager version does not register any root namespaces, so you must do it manually</i></p>\n<h2 id=\"instanceof-operator\">Instanceof operator</h2>\n<p>Lava classes do not have prototype chain - there is no need for it. Having one prototype with all required methods and members -\nis a faster, easier to debug and more convenient solution. This also means, that native JavaScript\n<span class=\"api-keyword\">instanceof</span> operator does not work.</p>\n<p>In a well-designed program there is no need for <span class=\"api-keyword\">instanceof</span> operator, cause objects of different types are not\nmixed together. Strong-typed programs have less bugs, they are much easier to develop and maintain.</p>\n<p>Instead of <span class=\"api-keyword\">instanceof</span> operator some Lava classes have a unique type marker in their class bodies,\nlike <a href=\"/www/doc.html#class=Lava.system.Enumerable;member=isEnumerable\">Enumerable#isEnumerable</a>, or <a href=\"/www/doc.html#class=Lava.mixin.Properties;member=isProperties\">Properties#isProperties</a>.\nBut if you really need it, there is analog of <span class=\"api-keyword\">instanceof</span> for Lava classes - <a href=\"/www/doc.html#object=Lava;member=instanceOf\">Lava#instanceOf</a>.</p>\n<h2 id=\"constructing-classes\">Constructing classes</h2>\n<p>If you know the exact class path, you can access class constructor directly.</p>\n<div class=\"lava-new-code-container lava-new-code-container-primary\"><div class=\"lava-new-code-box\"><pre class=\"lava-new-code-line-numbers\">&nbsp;&nbsp;1\r\n2\r\n</pre><div class=\"lava-new-code-overlays\"><pre class=\"lava-new-code-content hljs javascript\"><span class=\"hljs-comment\">// way 1: create class directly</span>\n<span class=\"hljs-keyword\">var</span> instance = <span class=\"hljs-keyword\">new</span> Lava.view.container.Element(<span class=\"hljs-comment\">/* ... */</span>);</pre></div></div></div><p>But often class names are stored in configs, in this case you can retrieve the constructor from ClassManager:</p>\n<div class=\"lava-new-code-container lava-new-code-container-primary\"><div class=\"lava-new-code-box\"><pre class=\"lava-new-code-line-numbers\">&nbsp;&nbsp;1\r\n2\r\n3\r\n4\r\n5\r\n</pre><div class=\"lava-new-code-overlays\"><pre class=\"lava-new-code-content hljs javascript\"><span class=\"hljs-comment\">// way 2: search for the constructor. Second argument is the namespace.</span>\n<span class=\"hljs-keyword\">var</span> constructor = lava.ClassManager.getConstructor(<span class=\"hljs-string\">'Element'</span>, <span class=\"hljs-string\">'Lava.view.container'</span>);\n<span class=\"hljs-keyword\">var</span> instance = <span class=\"hljs-keyword\">new</span> constructor(<span class=\"hljs-comment\">/* ... */</span>);\n<span class=\"hljs-comment\">// or you can pass full path</span>\n<span class=\"hljs-keyword\">var</span> constructor = lava.ClassManager.getConstructor(<span class=\"hljs-string\">'Lava.view.container.Element'</span>);</pre></div></div></div><p>See also: <a href=\"/www/doc.html#object=Lava.ClassManager;member=getConstructor\">ClassManager#getConstructor</a> source code.</p>\n<h2 id=\"lava-define\">Lava.define</h2>\n<p>Before call to <a href=\"/www/doc.html#object=Lava;member=init\">Lava#init</a> - <a href=\"/www/doc.html#object=Lava;member=define\">Lava#define</a> puts class bodies into <a href=\"/www/doc.html#object=Lava;member=classes\">Lava#classes</a> object,\nand after call to <code>init()</code> - it becomes direct proxy to <a href=\"/www/doc.html#object=Lava.ClassManager;member=define\">ClassManager#define</a>.\n<code>init()</code> then recursively loads all class bodies, stored in <a href=\"/www/doc.html#object=Lava;member=classes\">Lava#classes</a> - this is done to allow user to modify any classes\nbefore they are loaded (&quot;monkey patching&quot;).</p>\n<p>Although such possibility exists - you should not misuse it.\nIt&#39;s designed for such rare cases like &quot;add possibility to switch locales on the fly&quot;, or applying patches,\nso if you really want to modify core classes - think again, it may be a sign that you are doing something wrong.\nFor most of your needs inheritance is more than enough.</p>\n<p><b>When writing your own classes - you must not call <a href=\"/www/doc.html#object=Lava.ClassManager;member=define\">ClassManager#define</a> directly,\nuse <a href=\"/www/doc.html#object=Lava;member=define\">Lava#define</a> instead.</b></p>\n<p><i>In standalone ClassManager version <code>Lava.define</code> is an alias to <code>Lava.ClassManager.define</code>.</i></p>\n<h2 id=\"architecture-notes\">Architecture notes</h2>\n<p>Class body, passed to <code>define()</code> is &quot;disassembled&quot; into <span class=\"api-var\">skeleton</span> - internal structure, which describes all class members.\n<span class=\"api-var\">skeleton</span> is then used for class extension and constructor generation.\nWhile building the <span class=\"api-var\">skeleton</span>, ClassManager stores functions from class body into <span class=\"api-var\">references</span> array.</p>\n<p>All internal class data is stored in <span class=\"api-var\">Class</span> property of each constructed instance,\nand described in <a href=\"/www/doc.html#object=Support;member=_cClassData\">_cClassData</a> helper object. For example, have a look at:</p>\n<div class=\"lava-new-code-container lava-new-code-container-primary\"><div class=\"lava-new-code-box\"><pre class=\"lava-new-code-line-numbers\">&nbsp;&nbsp;1\r\n2\r\n3\r\n4\r\n5\r\n</pre><div class=\"lava-new-code-overlays\"><pre class=\"lava-new-code-content hljs javascript\"><span class=\"hljs-comment\">// type in console</span>\nLava.widget.Standard.prototype.Class;\n\n<span class=\"hljs-comment\">// or inside a class instance:</span>\n<span class=\"hljs-comment\">// this.Class</span></pre></div></div></div><p>Keep in mind, that everything inside <span class=\"api-var\">Class</span> is readonly.</p>\n<h2 id=\"class-directives\">Class directives</h2>\n<h3 id=\"extends\">Extends</h3>\n<p>All members from parent class are merged into inherited class.\nCertain limitations exist, for example if member of parent class was a function,\nthan it cannot become a string or object in child (adequate programmer should not try to do it, anyway).\nObjects from parent and child are merged recursively.</p>\n<p>When a method is overridden in child class - parent&#39;s method is renamed:\na prefix of short parent&#39;s name and dollar sign are added before it. For example,\nwhen you inherit from &quot;Lava.data.field.Abstract&quot; - all parent methods will start with &quot;Abstract$&quot;.</p>\n<p>Multiple inheritance is not allowed. Usage example:</p>\n<div class=\"lava-new-code-container lava-new-code-container-primary\"><div class=\"lava-new-code-box\"><pre class=\"lava-new-code-line-numbers\">&nbsp;&nbsp;1\r\n2\r\n3\r\n4\r\n5\r\n6\r\n7\r\n8\r\n9\r\n10\r\n</pre><div class=\"lava-new-code-overlays\"><pre class=\"lava-new-code-content hljs javascript\">Lava.define(\n<span class=\"hljs-string\">'Lava.widget.MyWidget'</span>,\n{\n    Extends: <span class=\"hljs-string\">'Lava.widget.Standard'</span>,\n\n    init: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(config, widget, parent_view, template, properties)</span> {</span>\n        <span class=\"hljs-keyword\">this</span>.Standard$init(config, widget, parent_view, template, properties);\n    }\n\n});</pre></div></div></div><p><b>Rule of thumb: you can only call overridden methods of a class you directly inherit.\nYou can not skip a call to parent&#39;s method and call &quot;grandfather&#39;s&quot; methods directly.</b></p>\n<p>Naming limitation: you can not have two classes with same short name in one inheritance chain \n(short name is the name after the last dot). For example: you can not create a class <code>Lava.widget.input.Abstract</code>, \ninherited from <code>Lava.widget.Standard</code>, cause the latter inherits from <code>Lava.view.Abstract</code>. This limitation arises from\nthe algorithm of <a href=\"/www/doc.html#object=Lava.ClassManager;member=patch\">ClassManager#patch</a> (see <a href=\"/www/doc.html#reference=ClassPatches\">Class patches</a>).</p>\n<h3 id=\"implements\">Implements</h3>\n<p>Is similar to Extends, with one difference: if child overrides a parent&#39;s method -\nthan overridden method is not renamed, but simply ignored.</p>\n<p>In other words - it copies to child everything, that does not already exists there. Example:</p>\n<div class=\"lava-new-code-container lava-new-code-container-primary\"><div class=\"lava-new-code-box\"><pre class=\"lava-new-code-line-numbers\">&nbsp;&nbsp;1\r\n2\r\n3\r\n4\r\n5\r\n</pre><div class=\"lava-new-code-overlays\"><pre class=\"lava-new-code-content hljs javascript\">Lava.define(\n<span class=\"hljs-string\">'Lava.user.MyClass'</span>,\n{\n    Implements: [<span class=\"hljs-string\">'Lava.mixin.Properties'</span>, <span class=\"hljs-string\">'Lava.user.MyMixin'</span>]\n});</pre></div></div></div><p>Implements can be used together with Extends. Several classes may be implemented with one directive.</p>\n<h3 id=\"shared\">Shared</h3>\n<p>Shared objects and arrays are moved to prototype, this makes them common to all class instances.</p>\n<p>When you inherit shared objects from parent - they are copied.\nIn the following example, all instances of &quot;MyClass&quot; and &quot;InheritedClass&quot; will have two different copies of <code>_shared_object</code>\nin their prototype. That means, that all instances of MyClass will have one copy of <code>shared_counter</code>,\nand all instances of InheritedClass will have their own.</p>\n<p>At the same time, <code>other_object</code> is copied by reference,\nso it will be shared among all class hierarchy, and <code>true_shared_counter</code> will be shared between parent and inherited class.</p>\n<div class=\"lava-new-code-container lava-new-code-container-primary\"><div class=\"lava-new-code-box\"><pre class=\"lava-new-code-line-numbers\">&nbsp;&nbsp;1\r\n2\r\n3\r\n4\r\n5\r\n6\r\n7\r\n8\r\n9\r\n10\r\n11\r\n12\r\n13\r\n14\r\n15\r\n16\r\n17\r\n18\r\n19\r\n</pre><div class=\"lava-new-code-overlays\"><pre class=\"lava-new-code-content hljs javascript\">Lava.define(<span class=\"hljs-string\">'Lava.user.MyClass'</span>, {\n    Shared: <span class=\"hljs-string\">'_shared'</span>,\n    <span class=\"hljs-comment\">// Shared: ['_shared_object', '_shared_array'], // you can share multiple objects</span>\n    _shared_object: {\n        shared_counter: <span class=\"hljs-number\">0</span>,\n        other_object: {\n            true_shared_counter: <span class=\"hljs-number\">0</span>\n        }\n    },\n    _shared_array: []\n});\n\nLava.define(<span class=\"hljs-string\">'Lava.user.InheritedClass'</span>, {\n    Extends: <span class=\"hljs-string\">'Lava.user.MyClass'</span>,\n\n    _shared_object: {\n        hello: <span class=\"hljs-string\">\"World\"</span>\n    }\n});</pre></div></div></div><p>Equivalent generated code:</p>\n<div class=\"lava-new-code-container lava-new-code-container-primary\"><div class=\"lava-new-code-box\"><pre class=\"lava-new-code-line-numbers\">&nbsp;&nbsp;1\r\n2\r\n3\r\n4\r\n5\r\n6\r\n7\r\n8\r\n9\r\n10\r\n11\r\n12\r\n13\r\n14\r\n15\r\n16\r\n17\r\n18\r\n</pre><div class=\"lava-new-code-overlays\"><pre class=\"lava-new-code-content hljs javascript\"><span class=\"hljs-comment\">// parent class</span>\nLava.user.MyClass = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> {</span><span class=\"hljs-comment\">/*...*/</span>}\nLava.user.MyClass.prototype._shared_object = {\n    shared_counter: <span class=\"hljs-number\">0</span>,\n    other_object: {\n        true_shared_counter: <span class=\"hljs-number\">0</span>\n    }\n};\nLava.user.MyClass.prototype._shared_array = []\n\n<span class=\"hljs-comment\">// inherited class</span>\nLava.user.InheritedClass = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> {</span><span class=\"hljs-comment\">/*...*/</span>}\n<span class=\"hljs-comment\">// copy shared object from parent</span>\nLava.user.InheritedClass.prototype._shared_object = Firestorm.Object.copy(Lava.user.MyClass.prototype._shared_object);\n<span class=\"hljs-comment\">// and merge own properties of inherited class</span>\nLava.user.InheritedClass.prototype._shared_object.hello = <span class=\"hljs-string\">\"World\"</span>;\n<span class=\"hljs-comment\">// arrays are assigned and overridden as-is</span>\nLava.user.InheritedClass.prototype._shared_array = Lava.user.MyClass.prototype._shared_array;</pre></div></div></div><p>When you override a shared object in inherited class - it&#39;s merged with parent (child members have priority).\nSeveral properties can be shared with one directive (<code>Shared: [/*...*/]</code>).</p>\n<h2 id=\"exporting-and-loading-classes\">Exporting and loading classes</h2>\n<p>Classes can be generated on server - this decreases page load time. Also, server-generated classes are faster in Firefox.\n<a href=\"/www/doc.html#object=Lava.ClassManager;member=exportClass\">ClassManager#exportClass</a> produces lots of excess data, which you should manually delete:</p>\n<div class=\"lava-new-code-container lava-new-code-container-primary\"><div class=\"lava-new-code-box\"><pre class=\"lava-new-code-line-numbers\">&nbsp;&nbsp;1\r\n2\r\n3\r\n4\r\n5\r\n6\r\n</pre><div class=\"lava-new-code-overlays\"><pre class=\"lava-new-code-content hljs javascript\"><span class=\"hljs-keyword\">var</span> exported = Lava.ClassManager.exportClass(<span class=\"hljs-string\">'Lava.mixin.Observable'</span>);\n<span class=\"hljs-keyword\">delete</span> exported.skeleton;\n<span class=\"hljs-keyword\">delete</span> exported.source_object;\n<span class=\"hljs-keyword\">delete</span> exported.references;\n<span class=\"hljs-comment\">//delete exported.own_references;</span>\nresult = <span class=\"hljs-string\">\"Lava.ClassManager.loadClass(\"</span> + Lava.serializer.serialize(exported) + <span class=\"hljs-string\">\");\\n\\n\"</span>;</pre></div></div></div><p><code>source_object</code> is the original class body: after class was built - it&#39;s not needed anymore. \nSkeletons are needed for inheritance, so if you want to inherit from exported classes - you can either do it on server,\nwhen skeletons are available, or export just the skeletons you need. For example, you can export skeleton for \n&quot;Lava.widget.Standard&quot; to be able to create widgets in browser.</p>\n<div class=\"lava-new-code-container lava-new-code-container-primary\"><div class=\"lava-new-code-box\"><pre class=\"lava-new-code-line-numbers\">&nbsp;&nbsp;1\r\n2\r\n3\r\n</pre><div class=\"lava-new-code-overlays\"><pre class=\"lava-new-code-content hljs javascript\">result = <span class=\"hljs-string\">\"Lava.widget.Standard.prototype.Class.skeleton = \"</span> \n    + Lava.serializer.serialize(Lava.widget.Standard.prototype.Class.skeleton);\n<span class=\"hljs-comment\">// write result to disk</span></pre></div></div></div><p>Also, two arrays with references are exported: <code>own_references</code> - just own methods of the class, from it&#39;s own body,\nand the full <code>references</code> array, which also includes methods from all class parents and mixins.\nIf your do not care about monomorphism - you should delete <code>references</code> and keep <code>own_references</code>.</p>\n<p>If you do otherwise (keep <code>references</code> and delete <code>own_references</code>) - this will allow you to create truly monomorphic \nclasses: each class will have it&#39;s own copy of every method it needs. This will produce a <b>huge</b> export file\nwith extremely fast classes - you can use this scenario for intranet sites and CMS admin panels. \nNote, that there is no reason to export full references array for polymorphic classes \n(those, which were created with <a href=\"/www/doc.html#object=Lava.ClassManager;member=is_monomorphic\">ClassManager#is_monomorphic</a> = <span class=\"api-keyword\">false</span>).</p>\n<h3 id=\"size-of-exported-classes\">Size of exported classes</h3>\n<p>Before gzip compression:</p>\n<ul>\n<li>exported classes (with partial references and without skeletons) are 60% bigger, then originals</li>\n<li>raw skeletons weight another 110% of original classes.</li>\n</ul>\n<p>After compression exported package weights just a bit more then original, but to achieve such result - \nit needs to be exported in proper way.</p>\n<p>To achieve best compression results - all similar data should be gathered in one place. \nFor example: object with all skeletons of the framework weights around 300KiB, \nbut minified and gzipped it weights just around 13KiB. The same skeletons, but scattered around exported file - \nwill weight much more.</p>\n<p><i>Lava build script exports compiled versions of framework classes and their skeletons in proper way: \nit gathers constructors, prototype generation functions and references in separate arrays.</i> \nYou can study sources of the export script as an example (see the <code>build/</code> directory of core Lava repository).\nExported classes can be found under <code>lib/compiled/</code> directory of Lava NPM package.</p>\n<p>If you want to export full <code>references</code> array - it&#39;s highly recommended, that you gather copies of every method in\none place. If you do such alignment - then gzipped exported file will be just 10-20% bigger (currently, \nthere are no examples that demonstrate it).</p>\n<p>Class manager has convenience methods to simplify loading: <a href=\"/www/doc.html#object=Lava.ClassManager;member=loadClasses\">ClassManager#loadClasses</a> and \n<a href=\"/www/doc.html#object=Lava.ClassManager;member=loadSkeletons\">ClassManager#loadSkeletons</a>.</p>\n<h2 id=\"limitations\">Limitations</h2>\n<p>You can not use compressor/mangler that renames methods in class bodies, cause this will break inheritance.\nGood-behaving compression tools will not do it, anyway.</p>\n<h2 id=\"see-also\">See also</h2>\n<p><a href=\"/www/doc.html#reference=Packages\">Packages</a></p>\n"],
	container: {
		type: "Element",
		tag_name: "div"
	}
}