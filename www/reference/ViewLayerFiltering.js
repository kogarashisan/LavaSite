{
	type: "widget",
	is_extended: true,
	template: ["<h1 id=\"view-layer-filtering\">View layer filtering</h1>\n<h2 id=\"role-of-enumerable-in-foreach-views\">Role of Enumerable in Foreach views</h2>\n<p><a href=\"/www/doc.html#class=Lava.view.Foreach\">Lava.view.Foreach</a> view always works with Enumerable or DataView, regardless of value, returned from it&#39;s Argument.\nWhen Argument returns a Properties instance, plain JavaScript array or common object -\nthen a new Enumerable instance is constructed and filled with values from argument result.</p>\n<p>Enumerable UIDs are used by Foreach view to cache it&#39;s item templates: they are stored in\n<a href=\"/www/doc.html#class=Lava.view.Foreach;member=_current_hash\">Foreach#_current_hash</a> - keys are UIDs, and values are <a href=\"/www/doc.html#class=Lava.system.Template\">Lava.system.Template</a> instances.\nEach time an UID is added or removed from source Enumerable - a new template is created or destroyed in the hash -\nthis allows to apply animation to template insertion and removal. And that&#39;s why using Enumerable for data binding \nmay result in faster performance.</p>\n<p>Certain Enumerable operations, like <code>sort()</code> or <code>filter()</code> - preserve existing UIDs, so if you bind Foreach directly to Enumerable,\nthen you can perform sorting faster, cause templates will not be destroyed or created during view refresh. \nThis will also allow you to reorder existing elements in DOM and apply animations.</p>\n<p>When you bind Foreach to plain object or Properties - UIDs are also preserved, so it&#39;s also possible to apply animation.\nHowever, when Enumerable is refreshed from native JavaScript array - a whole new set of UIDs is generated,\nso in this case you can not apply animation properly.</p>\n<h2 id=\"lava-scope-foreach\">Lava.scope.Foreach</h2>\n<p>Functionality of Foreach view is split into two parts: the view itself, which manages templates, \nand <a href=\"/www/doc.html#class=Lava.scope.Foreach\">Lava.scope.Foreach</a>, which prepares Enumerable for the view.</p>\n<p>When Argument of the scope returns Enumerable or DataView - scope passes it to view without modifications (default behaviour).\nIf Argument returns Properties, plain JavaScript array or object - then scope constructs an Enumerable instance from \nargument result and supplies it to it&#39;s view. Scope also listens for changes in data source\nand refreshes it&#39;s Enumerable when needed (for example, when a new property is added to Properties).</p>\n<p>From it&#39;s side, Foreach view creates and destroys templates, which correspond to items in Enumerable.</p>\n<h2 id=\"application\">Application</h2>\n<p>View filtering exists to satisfy the following requirements:</p>\n<ol>\n<li>You need to sort and filter items in Foreach.</li>\n<li>Item templates in Foreach can be independently inserted and removed from DOM. </li>\n<li>When you perform sorting or filtering - each item is inserted or removed independently from others.</li>\n<li>Animation can be applied to item sorting, insertion and removal.</li>\n</ol>\n<p>Simplest way to satisfy the second requirement would be to put one view with an Element container inside item template,\nbut in real world scenarios it can be any region, delimited by HTML elements (like Morph container, \nor plain text between any HTML tags).</p>\n<p>To satisfy the last two - there must be Enumerable/DataView pair, so you could preserve UIDs while performing \nsorting and filtering operations.</p>\n<p>Scope supports two options: </p>\n<ul>\n<li><code>own_enumerable_mode</code>: can be &quot;DataView&quot; or &quot;Enumerable&quot;</li>\n<li><code>depends</code>: semicolon-separated list of paths to properties, that will trigger scope refresh when changed</li>\n</ul>\n<p>Scope also emits <a href=\"/www/doc.html#class=Lava.scope.Foreach;event=after_refresh\">after_refresh</a> event, which is the right moment to apply changes (see example below).</p>\n<h2 id=\"example\">Example</h2>\n<div class=\"lava-new-code-container lava-new-code-container-primary \"><div class=\"lava-new-code-header api-code-header-blue\">Template</div>\n<div class=\"lava-new-code-box\"><pre class=\"lava-new-code-line-numbers\">&nbsp;&nbsp;1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n</pre><div class=\"lava-new-code-overlays\"><pre class=\"lava-new-code-content hljs xml\">{$foreach(records)\n  as=record\n  own_enumerable_mode=DataView\n  depends=\"$example.filter_text\"}\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">x:roles</span>&gt;</span>$example.main_foreach<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">x:roles</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">x:refresher</span>&gt;</span>{type: 'Standard'}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">x:refresher</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">div</span> <span class=\"lava-control-prefix\">x</span><span class=\"hljs-attribute\">:type</span>=<span class=\"hljs-value\">\"container\"</span>&gt;</span>\n    {#&gt; record.title}\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">div</span>&gt;</span>\n{/foreach}</pre></div></div><div class=\"lava-new-code-header api-code-header-blue\">Class</div>\n<div class=\"lava-new-code-box\"><pre class=\"lava-new-code-line-numbers\">&nbsp;&nbsp;1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n</pre><div class=\"lava-new-code-overlays\"><pre class=\"lava-new-code-content hljs javascript\">Lava.define(\n<span class=\"hljs-string\">'Lava.widget.Example'</span>,\n{\n  Extends: <span class=\"hljs-string\">'Lava.widget.Standard'</span>,\n  name: <span class=\"hljs-string\">\"example\"</span>,\n\n  _properties: {\n    filter_text: <span class=\"hljs-string\">''</span>,\n    records: <span class=\"hljs-literal\">null</span>\n  },\n\n  _role_handlers: {\n    main_foreach: <span class=\"hljs-string\">'_handleMainForeachView'</span>\n  },\n\n  _handleMainForeachView: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(foreach_view)</span> {</span>\n\n    foreach_view.getScope().on(<span class=\"hljs-string\">'after_refresh'</span>, <span class=\"hljs-keyword\">this</span>._onAfterForeachScopeRefreshed, <span class=\"hljs-keyword\">this</span>);\n\n  },\n\n  _onAfterForeachScopeRefreshed: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(foreach_scope)</span> {</span>\n\n    foreach_scope.getValue().filter(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(record)</span>{</span>\n\n      <span class=\"hljs-keyword\">return</span> record.get(<span class=\"hljs-string\">'title'</span>).indexOf(<span class=\"hljs-keyword\">this</span>._properties.filter_text) != -<span class=\"hljs-number\">1</span>;\n\n    });\n\n  }\n\n});</pre></div></div></div><p>This example performs filtering of <code>records</code> inside Foreach when <code>filter_text</code> property changes.</p>\n<p>First, template defines a Foreach with single view inside (&lt;div x:type=&quot;container&quot;&gt;).\nSuch templates can be inserted and removed independently with standard framework functionality.</p>\n<p>&lt;x:refresher&gt; directive defines refresher - a unit, which performs insertion and removal of templates\n(without refresher list would be re-rendered with each change).\n<code>own_enumerable_mode</code> and <code>depends</code> options are passed directly to scope (Foreach view does not care, if they are present).</p>\n<p>And finally, view is registered with a role, which attaches handler to scope&#39;s <span class=\"api-string\">&quot;after_refresh&quot;</span> event:</p>\n<div class=\"lava-new-code-container lava-new-code-container-primary\"><div class=\"lava-new-code-box\"><pre class=\"lava-new-code-line-numbers\">&nbsp;&nbsp;1\r\n</pre><div class=\"lava-new-code-overlays\"><pre class=\"lava-new-code-content hljs javascript\">foreach_view.getScope().on(<span class=\"hljs-string\">'after_refresh'</span>, <span class=\"hljs-keyword\">this</span>._onAfterForeachScopeRefreshed, <span class=\"hljs-keyword\">this</span>);</pre></div></div></div><p><span class=\"api-string\">&quot;after_refresh&quot;</span> is raised every time:</p>\n<ul>\n<li>Argument value changes (it returns another instance of Enumerable, array, or something else).</li>\n<li>data source changes. For example, if argument has returned Properties, and one it&#39;s property has changed.</li>\n<li>scope from &quot;depends&quot; changes. That&#39;s the purpose of the &quot;depends&quot; options.</li>\n</ul>\n<p>For this example to work, <code>records</code> must be instance of Enumerable (plain array will not work).\nBy default, scope.Foreach passes Enumerable to it&#39;s view, but <code>own_enumerable_mode</code> forces it to create a DataView\ninstance and refresh it from argument result. The <code>foreach_scope.getValue()</code> expression in the handler retrieves that\nDataView instance and filters it.</p>\n<p>Data flow in this example:</p>\n<div class=\"lava-new-code-container lava-new-code-container-primary\"><div class=\"lava-new-code-box\"><pre class=\"lava-new-code-line-numbers\">&nbsp;&nbsp;1\r\n</pre><div class=\"lava-new-code-overlays\"><pre class=\"lava-new-code-content hljs text\">$example.records -> Argument -> scope.Foreach -> DataView -> view.Foreach</pre></div></div></div><h2 id=\"limitations\">Limitations</h2>\n<p>First of all, you should never edit original Enumerable instance in <span class=\"api-string\">&quot;after_refresh&quot;</span> event.\nFramework was not designed for such behaviour; it may also lead to unmaintainable program architecture.\nif you listen to <span class=\"api-string\">&quot;after_refresh&quot;</span> event - then do not forget to provide <code>own_enumerable_mode</code> option.</p>\n<p>Also be careful about data modifications in <span class=\"api-string\">&quot;after_refresh&quot;</span> event handler. It&#39;s absolutely safe to retrieve \nthe DataView from scope (<code>foreach_scope.getValue()</code>), then filter and sort it. You can also modify data, \nthat is displayed inside the current Foreach view (see the related \n<a href=\"/www/examples.html#ViewLayerFiltering\">&quot;View layer filtering&quot;</a> example - it does just that).</p>\n<p>But you should not modify data, that is displayed outside of the current Foreach view, especially in it&#39;s parents:\nthis may lead to performance degradation and errors in view refresh system.</p>\n<h2 id=\"see-also\">See also</h2>\n<p>See the view-layer filtering examples: <a href=\"/www/examples.html#ViewLayerFiltering\">list</a>, <a href=\"/www/examples.html#FilteredTree\">tree</a>.</p>\n<p>Also you are recommended to study the source of <a href=\"/www/doc.html#class=Lava.scope.Foreach\">Lava.scope.Foreach</a> and <a href=\"/www/doc.html#class=Lava.view.Foreach\">Lava.view.Foreach</a> - \nit will answer all your questions and give you clear understanding.</p>\n"],
	container: {
		type: "Element",
		tag_name: "div"
	}
}