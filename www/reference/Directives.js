{
	type: "widget",
	is_extended: true,
	template: ["<h1 id=\"directives\">Directives</h1>\n<p>Directives are tags from &quot;x&quot; namespace, like &lt;x:define&gt;.</p>\n<p>In Lava framework, templates are not compiled into JavaScript functions,\nbut instead <a href=\"/www/doc.html#object=Lava.TemplateParser;member=parse\">TemplateParser.parse</a> produces configs for classes from &quot;Lava.view&quot; namespace.\nDirectives provide syntax for modifying view and widget configs.</p>\n<table class=\"api-member-table\"><thead><tr><td>Directive</td><td>Result</td><td>Is top directive</td><td>Widget only</td></tr></thead><tbody><tr><td>define</td><td></td><td>Outside</td><td></td></tr><tr><td>define_resources</td><td></td><td>Outside</td><td></td></tr><tr><td>widget</td><td>Yes</td><td></td><td></td></tr><tr><td>static_value</td><td>Yes</td><td></td><td></td></tr><tr><td>static_eval</td><td>Yes</td><td></td><td></td></tr><tr><td>attach_directives</td><td>Yes</td><td></td><td></td></tr><tr><td>assign</td><td></td><td>Yes</td><td></td></tr><tr><td>roles</td><td></td><td>Yes</td><td></td></tr><tr><td>container_config</td><td></td><td>Yes</td><td></td></tr><tr><td>refresher</td><td></td><td>Yes</td><td></td></tr><tr><td>option</td><td></td><td>Yes</td><td></td></tr><tr><td>options</td><td></td><td>Yes</td><td></td></tr><tr><td>broadcast</td><td></td><td>Yes</td><td>Yes</td></tr><tr><td>bind</td><td></td><td>Yes</td><td>Yes</td></tr><tr><td>property</td><td></td><td>Yes</td><td>Yes</td></tr><tr><td>properties</td><td></td><td>Yes</td><td>Yes</td></tr><tr><td>property_string</td><td></td><td>Yes</td><td>Yes</td></tr><tr><td>resources</td><td></td><td>Yes</td><td>Yes</td></tr><tr><td>default_events</td><td></td><td>Yes</td><td>Yes</td></tr></tbody></table>\n\n<h2 id=\"top-directives\">Top directives</h2>\n<p>&quot;Is top directive&quot; flag is set on all directives, that modify view&#39;s configs - it forces directive to appear\nbefore any content inside views and widgets.\nThis is done to maintain good codestyle among LiquidLava developers. For example:</p>\n<div class=\"lava-code-container\"><div class=\"lava-code\"><pre class=\"lava-code-line-numbers\">&nbsp;&nbsp;1\r\n2\r\n3\r\n4\r\n</pre><pre class=\"lava-code-content hljs xml\">{#view()}\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">x:option</span> <span class=\"hljs-attribute\">name</span>=<span class=\"hljs-value\">\"test_option\"</span>&gt;</span>\"option_value\"<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">x:option</span>&gt;</span>\n    This is content\n{/view}</pre></div></div><p>You cannot move &lt;x:option&gt; directive after any text inside the view - otherwise you will get an exception.\nAlso, you cannot insert any directive, that produces result before it, like &lt;x:widget&gt;.</p>\n<p>Special cases: x:define and x:define_resources directives must be outside of view or widget configs.\nYou must always put them at the root of your templates.</p>\n<h2 id=\"directive-results\">Directive results</h2>\n<p>Most directives does not yield a result, instead they modify configs of their widgets. Some special directives,\nlike x:define and x:define_resource - modify global data from Lava.widgets property. And some of them, like x:widget -\nreturn template items (in this case - a widget config).</p>\n<h2 id=\"architecture\">Architecture</h2>\n<p><a href=\"/www/doc.html#object=Lava.parsers.Directives;member=processDirective\">Directives.processDirective</a> is the method you can manually call to apply directives to a view&#39;s config\nand get their results.</p>\n"],
	container: {
		"class": "Element",
		tag_name: "div"
	}
}