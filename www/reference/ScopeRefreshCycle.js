{
	type: "widget",
	is_extended: true,
	template: ["<h1 id=\"scope-refresh-cycle\">Scope refresh cycle</h1>\n<p>Scopes are connected to each other with &quot;changed&quot; events. Have a look at the following example:</p>\n<div class=\"lava-new-code-container lava-new-code-container-primary\"><div class=\"lava-new-code-box\"><pre class=\"lava-new-code-line-numbers\">&nbsp;&nbsp;1\r\n</pre><div class=\"lava-new-code-overlays\"><pre class=\"lava-new-code-content hljs text\">{#> $widget.property1.property2 }</pre></div></div></div><p>This expression displays result of an Argument, which returns the value of DataBinding (to &quot;property2&quot;),\nwhich is bound to PropertyBinding (bound to &quot;property1&quot; in $widget).</p>\n<p>Now what if we sequentially modify both properties?</p>\n<div class=\"lava-new-code-container lava-new-code-container-primary\"><div class=\"lava-new-code-box\"><pre class=\"lava-new-code-line-numbers\">&nbsp;&nbsp;1\r\n2\r\n3\r\n</pre><div class=\"lava-new-code-overlays\"><pre class=\"lava-new-code-content hljs javascript\"><span class=\"hljs-keyword\">var</span> widget = ... <span class=\"hljs-comment\">// get widget</span>\nwidget.get(<span class=\"hljs-string\">\"property1\"</span>).set(<span class=\"hljs-string\">\"property2\"</span>, <span class=\"hljs-string\">\"test\"</span>);\nwidget.set(<span class=\"hljs-string\">\"property1\"</span>, {property2: <span class=\"hljs-string\">'new value'</span>});</pre></div></div></div><p>If scopes were updating immediately - then Argument would be updated twice, which could result in performance degradation.</p>\n<p>When scope receives &quot;changed&quot; event from it&#39;s dependent scopes or bound data - it does not refresh itself immediately.\nInstead, it places itself into the refresh queue in <a href=\"/www/doc.html#object=Lava.ScopeManager\">Lava.ScopeManager</a> - it&#39;s job is to update scopes in correct order.</p>\n<p>So, full refresh cycle in Lava consists of two parts: first - a call to <a href=\"/www/doc.html#object=Lava.ScopeManager;member=refresh\">ScopeManager#refresh</a>, \nwhich refreshes scope hierarchy, then call to <a href=\"/www/doc.html#class=Lava.system.ViewManager;member=refresh\">ViewManager#refresh</a>, which refreshes views.</p>\n<h2 id=\"refresh-order\">Refresh order</h2>\n<p>ScopeManager needs to maintain correct refresh order of scopes.\nFor this purpose scopes have the <a href=\"/www/doc.html#class=Lava.mixin.Refreshable;member=level\">Refreshable#level</a> property,\nwhich is chosen by the following rule: level of scope must be higher, then level of it&#39;s dependencies.</p>\n<p>Level of PropertyBinding is equal to <a href=\"/www/doc.html#class=Lava.view.Abstract;member=depth\">Abstract#depth</a> of it&#39;s bound view \n(it matters in complex scenarios). Level of DataBinding is equal to &quot;level of it&#39;s PropertyBinding + 1&quot;.\nSegment and Argument depend on multiple scopes, so their level is &quot;max(&lt;level of dependencies&gt;) + 1&quot;.</p>\n<p>The above example is shown on the following diagram:</p>\n<p><a href=\"/www/reference_img/scope-refresh-diagram.png\" target=\"_blank\">\n    <img src=\"/www/reference_img/scope-refresh-diagram.png\" style=\"width: 50%;\"/>\n</a></p>\n<p><b>When scopes are placed into the refresh queue - they are sorted by their level.</b></p>\n<h2 id=\"the-refresh-operation\">The refresh operation</h2>\n<p>Scope refresh cycle happens in <a href=\"/www/doc.html#object=Lava.ScopeManager;member=refresh\">ScopeManager#refresh</a> - it calls <a href=\"/www/doc.html#class=Lava.mixin.Refreshable;member=refresh\">Refreshable#refresh</a>\nof each scope in it&#39;s queue, starting from scopes with lower levels, to scopes with higher levels. \nDuring the cycle new scopes can be added into the refresh queue.</p>\n<p>Scope&#39;s <code>refresh()</code> operation updates it&#39;s <code>_value</code> property, and if old and new values differ - also fires &quot;changed&quot; event.</p>\n<h2 id=\"example-cycle\">Example cycle</h2>\n<p>Let&#39;s update &quot;property1&quot; in previous example, and launch the refresh cycle:</p>\n<div class=\"lava-new-code-container lava-new-code-container-primary\"><div class=\"lava-new-code-box\"><pre class=\"lava-new-code-line-numbers\">&nbsp;&nbsp;1\r\n2\r\n</pre><div class=\"lava-new-code-overlays\"><pre class=\"lava-new-code-content hljs javascript\">widget.set(<span class=\"hljs-string\">\"property1\"</span>, {property2: <span class=\"hljs-string\">'some value'</span>});\nLava.ScopeManager.refresh();</pre></div></div></div><p>PropertyBinding listens to widget&#39;s onPropertyChanged, so when &quot;property1&quot; was set to new value - \nit placed itself into the refresh queue. For clarity, let&#39;s assume that now it&#39;s the only scope in the queue.</p>\n<p>In refresh cycle, ScopeManager calls <code>refresh</code> of PropertyBinding, which fires it&#39;s own &quot;changed&quot; event\n(new value is an object, so in this case it&#39;s guaranteed that old and new values of &quot;property1&quot; differ).\nWhen DataBinding receives &quot;changed&quot; event from PropertyBinding - it places itself into refresh queue,\nand refresh cycle continues. ScopeManager refreshes DataBinding, and if it&#39;s value differs - then it also fires &quot;changed&quot;.</p>\n<p>Old value of DataBinding could be same as the new one - <span class=\"api-string\">&quot;some value&quot;</span>. If old and new values are the same - \nthen it will not fire &quot;changed&quot; event, but if they differ - then Argument will be placed into refresh queue and\nrefreshed, notifying it&#39;s view.</p>\n<p>Expression view listens to &quot;changed&quot; event from argument, and when it occurs - it will place itself into view refresh \nqueue in ViewManager.</p>\n<p>Tip: if you want to understand this process better - then it&#39;s a good idea to watch it in debugger.</p>\n<h2 id=\"nuances\">Nuances</h2>\n<p>Refreshing views in a framework - is a difficult task, so refresh cycle is not ideal.</p>\n<p>It&#39;s possible to modify data in view refresh cycle (in <code>refresh()</code> and <code>render()</code>), \nand it&#39;s extremely hard to create application lifecycle, that would not do that.\nFor example, Foreach view performs data modification during refresh.</p>\n<p>As a workaround for that, when view refresh cycle starts - it turns ScopeManager into immediate refresh mode.\nIf a new scope is submitted into ScopeManager during view refresh cycle - it&#39;s not put into refresh queue, \nbut rather refreshed immediately. </p>\n<p>Due to this fact, it&#39;s possible to create applications, which can have performance issues due to wrong<br/>scope refresh order. In practice, it&#39;s very hard to degrade performance of Lava application to noticeable level by \nrefreshing scopes in wrong order, so probably you should not worry about that.</p>\n<p>Recommendation: if you can - then try to avoid data manipulations in view&#39;s <code>refresh()</code> and <code>render()</code> methods.\nThe right place to change data is event listeners - in this case most of scopes will be refreshed before view \nrefresh cycle starts.</p>\n<h2 id=\"dead-loops\">Dead loops</h2>\n<p>It&#39;s possible to create eternal refresh loops - when setting property to child widget triggers change of property in \nparent widget, which in turn triggers change of property in same child widget... \nThese situations can be artificially created with wrong program logic\n(Lava framework is not responsible for them, only the widget developer).</p>\n<p>Scope system has protection from eternal loops, so if this happens - browser will not hang up,\nand framework will try to continue normal operation, but user may experience lags and interface glitches.</p>\n"],
	container: {
		type: "Element",
		tag_name: "div"
	}
}