{
	type: "widget",
	is_extended: true,
	template: ["<h1 id=\"common-pitfalls\">Common pitfalls</h1>\n<h2 id=\"-lt-view-gt-versus-lt-template-gt-\">&lt;view&gt; versus &lt;template&gt;</h2>\n<p>Widget, like any other view, can have a container. You can give it a container with the &lt;view&gt; tag in\nwidget definition, and there is nothing bad in doing so.</p>\n<p>Problems start to arise when container plays special role in widget lifecycle, for example\nwhen you assign properties to your container in widget constructor or other methods.</p>\n<p>This is best illustrated by the framework&#39;s input widgets. They all have single void (!) input tag in their templates:</p>\n<div class=\"lava-code-container\"><div class=\"lava-code\"><pre class=\"lava-code-line-numbers\">&nbsp;&nbsp;1\r\n2\r\n3\r\n4\r\n5\r\n6\r\n7\r\n8\r\n9\r\n10\r\n11\r\n</pre><pre class=\"lava-code-content hljs xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">x:define</span> <span class=\"hljs-attribute\">controller</span>=<span class=\"hljs-value\">\"input.Text\"</span> <span class=\"hljs-attribute\">title</span>=<span class=\"hljs-value\">\"TextInput\"</span> <span class=\"hljs-attribute\">extends</span>=<span class=\"hljs-value\">\"InputAbstract\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">include</span> <span class=\"hljs-attribute\">name</span>=<span class=\"hljs-value\">\"input_view\"</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">input\n</span>            <span class=\"lava-control-prefix\">x</span><span class=\"hljs-attribute\">:type</span>=<span class=\"hljs-value\">\"view\"</span>\n            <span class=\"lava-control-prefix\">x</span><span class=\"hljs-attribute\">:roles</span>=<span class=\"hljs-value\">\"_input_view\"</span>\n\n            <span class=\"lava-control-prefix\">x</span><span class=\"hljs-attribute\">:event:change</span>=<span class=\"hljs-value\">\"$text_input.value_changed\"</span>\n            <span class=\"lava-control-prefix\">x</span><span class=\"hljs-attribute\">:bind:name</span>=<span class=\"hljs-value\">\"$text_input.name\"</span>\n            <span class=\"hljs-attribute\">...</span> /&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">include</span>&gt;</span>\n    ...</pre></div></div><p>Why not to turn this input tag into widget&#39;s container? We could get rid of another view inside our widget.\nBut instead, this view is registered by role (<code>x:roles=&quot;_input_view&quot;</code>), then saved into property (<code>_input_container</code>),\nand there are checks for it inside the widget, like:</p>\n<div class=\"lava-code-container\"><div class=\"lava-code\"><pre class=\"lava-code-line-numbers\">&nbsp;&nbsp;1\r\n2\r\n3\r\n4\r\n5\r\n6\r\n7\r\n8\r\n9\r\n10\r\n11\r\n12\r\n13\r\n14\r\n15\r\n16\r\n</pre><pre class=\"lava-code-content hljs javascript\">focus: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span>{</span>\n\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>._input_container &amp;&amp; <span class=\"hljs-keyword\">this</span>._input_container.isInDOM()) {\n        <span class=\"hljs-keyword\">this</span>._input_container.getDOMElement().focus();\n    }\n\n},\n_setValue: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(value)</span> {</span>\n\n    <span class=\"hljs-keyword\">this</span>._set(<span class=\"hljs-string\">'value'</span>, value);\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>._input_container) {\n        <span class=\"hljs-keyword\">this</span>._input_container.setProperty(<span class=\"hljs-string\">'value'</span>, <span class=\"hljs-keyword\">this</span>._valueToElementProperty(value));\n    }\n\n}\n...</pre></div></div><p>We could convert this view into widget&#39;s container and reference it directly: <code>this._container.setProperty(...)</code>,\nbut that would make our design inflexible.</p>\n<p>For example, we want to add a &lt;label&gt; before &lt;input&gt;, or add a dropdown Calendar widget after it \n(for date picker inputs): when input tag is widget&#39;s container - it&#39;s simply impossible.</p>\n<p>Summary: there is nothing bad in giving your widget it&#39;s own container, until you start to manually access it.\nIn this case it&#39;s highly recommended to convert &lt;view&gt; into &lt;template&gt; and register it by role, \notherwise your design will become inflexible. </p>\n<p>And it matters for all tags, not just void (for example, you can not wrap your own container in another tag).</p>\n<h2 id=\"views-versus-linear-logic\">Views versus linear logic</h2>\n<p>Consider the following template:</p>\n<div class=\"lava-code-container\"><div class=\"lava-code\"><pre class=\"lava-code-line-numbers\">&nbsp;&nbsp;1\r\n2\r\n3\r\n</pre><pre class=\"lava-code-content hljs xml\">{#if(#page.something)}\n    {#&gt; #page.my_modifier(#page.something)}\n{/if}</pre></div></div><p>You can think that argument, which you pass to modifier, will never be <span class=\"api-keyword\">null</span> or <span class=\"api-keyword\">false</span>, \nbut this is not always true, cause this is not a JavaScript <span class=\"api-keyword\">if</span> operator.\nThis template defines two views, outer If and inner Expression, which are bound to\nArgument instances, which receive values from same PropertyBinding.</p>\n<p>Let&#39;s assume, that currently <code>#page.something</code> evaluates to true, so both views are created and in DOM.\nNow we set <code>something</code> to null. What will happen? Both views are still created, still in DOM, \nand framework starts the scope refresh cycle.\nBoth arguments evaluate their value and fire &quot;changed&quot; events... and this is the moment, when modifier receives <span class=\"api-keyword\">null</span>.</p>\n<p>When scope refresh loop starts - PropertyBinding that evaluates <code>#page.something</code> fires &quot;changed&quot; event,\nand both arguments are placed into refresh queue. When inner argument is refreshed - \nat this moment <code>#page.something</code> is <span class=\"api-keyword\">null</span>, so <code>#page.my_modifier</code> receives <span class=\"api-keyword\">null</span> instead of expected value.</p>\n<p>Later, when view refresh cycle starts, the outer If view will detect, that it&#39;s argument is <span class=\"api-keyword\">false</span> now,\nso now it may decide to destroy it&#39;s template with inner Expression view, but this will happen after both\narguments are refreshed.</p>\n<p>Summary: inside modifiers you should always check passed argument values for nulls.</p>\n<p>See also: <a href=\"/www/doc.html#reference=ScopeRefreshCycle\">Scope refresh cycle</a></p>\n"],
	container: {
		type: "Element",
		tag_name: "div"
	}
}