{
	type: "widget",
	is_extended: true,
	template: ["<h1 id=\"common-pitfalls\">Common pitfalls</h1>\n<h2 id=\"-lt-view-gt-versus-lt-template-gt-\">&lt;view&gt; versus &lt;template&gt;</h2>\n<p>Widget, like any other view, can have a container. You can give it a container with the &lt;view&gt; tag in\nwidget definition, and there is nothing bad in doing so.</p>\n<p>Problems start to arise when container plays special role in widget lifecycle, for example\nwhen you assign properties to your container in widget constructor or other methods.</p>\n<p>This is best illustrated by the framework&#39;s input widgets. They all have single void (!) input tag in their templates:</p>\n<div class=\"lava-code-container\"><div class=\"lava-code\"><pre class=\"lava-code-line-numbers\">&nbsp;&nbsp;1\r\n2\r\n3\r\n4\r\n5\r\n6\r\n7\r\n8\r\n9\r\n10\r\n11\r\n</pre><pre class=\"lava-code-content hljs xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">x:define</span> <span class=\"hljs-attribute\">controller</span>=<span class=\"hljs-value\">\"input.Text\"</span> <span class=\"hljs-attribute\">title</span>=<span class=\"hljs-value\">\"TextInput\"</span> <span class=\"hljs-attribute\">extends</span>=<span class=\"hljs-value\">\"InputAbstract\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">include</span> <span class=\"hljs-attribute\">name</span>=<span class=\"hljs-value\">\"input_view\"</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">input\n</span>            <span class=\"lava-control-prefix\">x</span><span class=\"hljs-attribute\">:type</span>=<span class=\"hljs-value\">\"view\"</span>\n            <span class=\"lava-control-prefix\">x</span><span class=\"hljs-attribute\">:roles</span>=<span class=\"hljs-value\">\"_input_view\"</span>\n\n            <span class=\"lava-control-prefix\">x</span><span class=\"hljs-attribute\">:event:change</span>=<span class=\"hljs-value\">\"$text_input.value_changed\"</span>\n            <span class=\"lava-control-prefix\">x</span><span class=\"hljs-attribute\">:bind:name</span>=<span class=\"hljs-value\">\"$text_input.name\"</span>\n            <span class=\"hljs-attribute\">...</span> /&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">include</span>&gt;</span>\n    ...</pre></div></div><p>Why not to turn this input tag into widget&#39;s container? We could get rid of another view inside our widget.\nBut instead, this view is registered by role (<code>x:roles=&quot;_input_view&quot;</code>), then saved into property (<code>_input_container</code>),\nand there are checks for it inside the widget, like:</p>\n<div class=\"lava-code-container\"><div class=\"lava-code\"><pre class=\"lava-code-line-numbers\">&nbsp;&nbsp;1\r\n2\r\n3\r\n4\r\n5\r\n6\r\n7\r\n8\r\n9\r\n10\r\n11\r\n12\r\n13\r\n14\r\n15\r\n16\r\n</pre><pre class=\"lava-code-content hljs javascript\">focus: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span>{</span>\n\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>._input_container &amp;&amp; <span class=\"hljs-keyword\">this</span>._input_container.isInDOM()) {\n        <span class=\"hljs-keyword\">this</span>._input_container.getDOMElement().focus();\n    }\n\n},\n_setValue: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(value)</span> {</span>\n\n    <span class=\"hljs-keyword\">this</span>._set(<span class=\"hljs-string\">'value'</span>, value);\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>._input_container) {\n        <span class=\"hljs-keyword\">this</span>._input_container.setProperty(<span class=\"hljs-string\">'value'</span>, <span class=\"hljs-keyword\">this</span>._valueToElementProperty(value));\n    }\n\n}\n...</pre></div></div><p>We could convert this view into widget&#39;s container and reference it directly: <code>this._container.setProperty(...)</code>,\nbut that would make our design inflexible.</p>\n<p>For example, we want to add a &lt;label&gt; before &lt;input&gt;, or add a dropdown Calendar widget after it \n(for date picker inputs): when input tag is widget&#39;s container - it&#39;s simply impossible.</p>\n<p>Summary: there is nothing bad in giving your widget it&#39;s own container, until you start to manually access it.\nIn this case it&#39;s highly recommended to convert &lt;view&gt; into &lt;template&gt; and register it by role, \notherwise your design will become inflexible. </p>\n<p>And it matters for all tags, not just void (for example, you can not wrap your own container in another tag).</p>\n<h2 id=\"views-versus-linear-logic\">Views versus linear logic</h2>\n<p>Consider the following template:</p>\n<div class=\"lava-code-container\"><div class=\"lava-code\"><pre class=\"lava-code-line-numbers\">&nbsp;&nbsp;1\r\n2\r\n3\r\n</pre><pre class=\"lava-code-content hljs xml\">{#if(#page.something)}\n    {#&gt; #page.my_modifier(#page.something)}\n{/if}</pre></div></div><p>You can think that argument, which you pass to modifier, will never be <span class=\"api-keyword\">null</span> or <span class=\"api-keyword\">false</span>, \nbut this is not always true, cause this is not a JavaScript <span class=\"api-keyword\">if</span> operator.\nThis template defines two views, outer If and inner Expression, which are bound to\nArgument instances, which receive values from same PropertyBinding.</p>\n<p>Let&#39;s assume, that currently <code>#page.something</code> evaluates to true, so both views are created and in DOM.\nNow we set <code>something</code> to null. What will happen? Both views are still created, still in DOM, \nand framework starts the scope refresh cycle.\nBoth arguments evaluate their value and fire &quot;changed&quot; events... and this is the moment, when modifier receives <span class=\"api-keyword\">null</span>.</p>\n<p>When scope refresh loop starts - PropertyBinding that evaluates <code>#page.something</code> fires &quot;changed&quot; event,\nand both arguments are placed into refresh queue. When inner argument is refreshed - \nat this moment <code>#page.something</code> is <span class=\"api-keyword\">null</span>, so <code>#page.my_modifier</code> receives <span class=\"api-keyword\">null</span> instead of expected value.</p>\n<p>Later, when view refresh cycle starts, the outer If view will detect, that it&#39;s argument is <span class=\"api-keyword\">false</span> now,\nso now it may decide to destroy it&#39;s template with inner Expression view, but this will happen after both\narguments are refreshed.</p>\n<p>Summary: inside modifiers you should always check passed argument values for nulls.</p>\n<p>See also: <a href=\"/www/doc.html#reference=ScopeRefreshCycle\">Scope refresh cycle</a></p>\n<h2 id=\"manual-widget-insertion\">Manual widget insertion</h2>\n<p>You should not do yourself something that can be done by framework. For example, you can insert widgets by hands:</p>\n<div class=\"lava-code-container lava-code-container-plain\"><div class=\"api-code-header api-code-header-blue\">Template</div>\n<div class=\"lava-code\"><pre class=\"lava-code-line-numbers\">&nbsp;&nbsp;1\n2\n3\n</pre><pre class=\"lava-code-content hljs xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">body</span>&gt;</span>\n  <span class=\"hljs-comment\">&lt;!-- empty body, without lava-app attribute --&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">body</span>&gt;</span></pre></div><div class=\"api-code-header api-code-header-blue\">Javascript</div>\n<div class=\"lava-code\"><pre class=\"lava-code-line-numbers\">&nbsp;&nbsp;1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n</pre><pre class=\"lava-code-content hljs javascript\">window.addEvent(<span class=\"hljs-string\">'load'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> {</span>\n\n    Lava.init();\n\n    <span class=\"hljs-comment\">// phase 1</span>\n    <span class=\"hljs-keyword\">var</span> instance = Lava.createWidget(<span class=\"hljs-string\">'CollapsiblePanel'</span>);\n    instance.set(<span class=\"hljs-string\">'title'</span>, <span class=\"hljs-string\">\"Old title\"</span>);\n    Firestorm.Element.setProperty(document.body, <span class=\"hljs-string\">'html'</span>, instance.render());\n    instance.broadcastInDOM();\n\n    <span class=\"hljs-comment\">// phase 2</span>\n    instance.set(<span class=\"hljs-string\">'title'</span>, <span class=\"hljs-string\">\"New title\"</span>);\n    Firestorm.Element.setProperty(document.body, <span class=\"hljs-string\">'html'</span>, instance.render());\n    instance.broadcastInDOM();\n\n});</pre></div></div><p>There is a glitch on this page: move cursor out of page area and hit F5 on your keyboard. Instead of what you expected - \nyou will see <span class=\"api-string\">&quot;Old title&quot;</span> string. If you move cursor into the page - right at that moment <span class=\"api-string\">&quot;Old title&quot;</span> \nwill be replaced with <span class=\"api-string\">&quot;New title&quot;</span>.</p>\n<p>What happened here: first, widget was created and rendered with <span class=\"api-string\">&quot;Old title&quot;</span>, then inserted into the page. \nNothing special here.</p>\n<p>Then you set a property on the widget. PropertyBinding, which is bound to <span class=\"api-string\">&quot;title&quot;</span>, places itself into the \nrefresh queue (it does not refresh itself immediately!). Now you render the widget with dirty PropertyBinding, \nwhich still serves the old title.</p>\n<p>When you move cursor into the page - an event occurs (each event ends with a view refresh cycle).\nSo widget is rendered and inserted with old data, and then refreshed.</p>\n<p>This specially matters, when you insert heavy widgets like Tree - first you render and insert the tree with old records,\nthen new records are rendered and inserted during the refresh cycle. Sometimes user will see the changes after\na click or other action, which makes this glitch even more noticeable.</p>\n<p>This would not happen, if you used widget&#39;s methods, which are designed for this purpose:</p>\n<div class=\"lava-code-container\"><div class=\"lava-code\"><pre class=\"lava-code-line-numbers\">&nbsp;&nbsp;1\r\n2\r\n3\r\n4\r\n5\r\n6\r\n7\r\n8\r\n9\r\n10\r\n11\r\n12\r\n13\r\n</pre><pre class=\"lava-code-content hljs javascript\">window.addEvent(<span class=\"hljs-string\">'load'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> {</span>\n\n    Lava.init();\n\n    <span class=\"hljs-keyword\">var</span> instance = Lava.createWidget(<span class=\"hljs-string\">'CollapsiblePanel'</span>);\n    instance.set(<span class=\"hljs-string\">'title'</span>, <span class=\"hljs-string\">\"Old title\"</span>);\n    instance.inject(document.body, <span class=\"hljs-string\">'Top'</span>);\n    instance.remove();\n\n    instance.set(<span class=\"hljs-string\">'title'</span>, <span class=\"hljs-string\">\"New title\"</span>);\n    instance.inject(document.body, <span class=\"hljs-string\">'Top'</span>);\n\n});</pre></div></div><p>Why this works correctly: inside <code>inject()</code> there is a call to <code>Lava.ScopeManager.refresh()</code> before <code>render()</code>.\nAnd call to <code>render()</code> is wrapped between calls to <code>Lava.ScopeManager.lock()</code> and <code>unlock()</code>.</p>\n<p>Summary: prefer using framework methods instead of doing something manually. \nUse <a href=\"/www/doc.html#class=Lava.widget.Standard;member=inject\">Standard#inject</a> and <a href=\"/www/doc.html#class=Lava.widget.Standard;member=injectIntoExistingElement\">Standard#injectIntoExistingElement</a> to insert widget \ninto DOM.</p>\n"],
	container: {
		type: "Element",
		tag_name: "div"
	}
}