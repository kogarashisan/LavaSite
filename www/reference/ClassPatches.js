{
	type: "widget",
	is_extended: true,
	template: ["<h2 id=\"patches-and-static-constructors\">Patches and static constructors</h2>\n<p>Sometimes you may want to apply browser fixes at run time - replace one method in a class prototype with another.\nBut you can not replace methods directly, as method names change during inheritance. </p>\n<p>Consider the following example:</p>\n<div class=\"lava-new-code-container lava-new-code-container-primary\"><div class=\"lava-new-code-box\"><pre class=\"lava-new-code-line-numbers\">&nbsp;&nbsp;1\r\n2\r\n3\r\n4\r\n5\r\n6\r\n7\r\n8\r\n9\r\n10\r\n11\r\n12\r\n13\r\n14\r\n15\r\n16\r\n17\r\n18\r\n19\r\n20\r\n21\r\n22\r\n23\r\n24\r\n25\r\n26\r\n27\r\n28\r\n29\r\n30\r\n31\r\n32\r\n33\r\n</pre><div class=\"lava-new-code-overlays\"><pre class=\"lava-new-code-content hljs javascript\">Lava.define(\n<span class=\"hljs-string\">'Lava.user.BottomClass'</span>,\n{\n\n    init: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> {</span>\n        <span class=\"hljs-comment\">// do something</span>\n    }\n\n});\n\nLava.define(\n<span class=\"hljs-string\">'Lava.user.MiddleClass'</span>,\n{\n\n    Extends: <span class=\"hljs-string\">\"Lava.user.BottomClass\"</span>,\n\n    init: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> {</span>\n        <span class=\"hljs-keyword\">this</span>.BottomClass$init();\n    }\n\n});\n\nLava.define(\n<span class=\"hljs-string\">'Lava.user.TopClass'</span>,\n{\n\n    Extends: <span class=\"hljs-string\">\"Lava.user.MiddleClass\"</span>,\n\n    init: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(init_arguments)</span> {</span>\n        <span class=\"hljs-keyword\">this</span>.MiddleClass$init();\n    }\n\n});</pre></div></div></div><p>Depending on inherited classes, the <code>init</code> method of <code>BottomClass</code> will be named differently:\nit will not be renamed inside the <code>BottomClass</code> itself, and in child classes, if they don&#39;t have their own <code>init</code>.\nIn <code>TopClass</code> from example above - it will be renamed to <code>BottomClass$init</code>, or into <code>MiddleClass$init</code>\n(if we remove <code>init</code> from the middle class).</p>\n<p>Now if &quot;BottomClass&quot; wants to replace <b>it&#39;s own</b> <code>init</code> in prototype - then it needs to find it&#39;s correct name.\nClassManager has <a href=\"/www/doc.html#object=Lava.ClassManager;member=patch\">patch</a> method, which does this job.</p>\n<h2 id=\"creating-a-static-constructor\">Creating a static constructor</h2>\n<p>You can create a class with a static constructor - <code>init</code> method, which will be called only once,\nwhen the first instance of that class is created. Then it can replace itself with another method, \nor even remove itself completely.</p>\n<div class=\"lava-new-code-container lava-new-code-container-primary\"><div class=\"lava-new-code-box\"><pre class=\"lava-new-code-line-numbers\">&nbsp;&nbsp;1\r\n2\r\n3\r\n4\r\n5\r\n6\r\n7\r\n8\r\n9\r\n10\r\n11\r\n12\r\n13\r\n14\r\n15\r\n16\r\n17\r\n18\r\n19\r\n20\r\n21\r\n22\r\n23\r\n24\r\n25\r\n26\r\n27\r\n28\r\n29\r\n30\r\n31\r\n32\r\n33\r\n34\r\n35\r\n36\r\n37\r\n38\r\n39\r\n40\r\n41\r\n42\r\n43\r\n44\r\n45\r\n46\r\n47\r\n48\r\n49\r\n50\r\n51\r\n52\r\n53\r\n54\r\n55\r\n56\r\n57\r\n58\r\n59\r\n60\r\n61\r\n62\r\n</pre><div class=\"lava-new-code-overlays\"><pre class=\"lava-new-code-content hljs javascript\">Lava.define(\n<span class=\"hljs-string\">'Lava.user.MyParentClass'</span>,\n{\n    init: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(init_arguments)</span> {</span>\n        <span class=\"hljs-comment\">// do something</span>\n    }\n});\n\nLava.define(\n<span class=\"hljs-string\">'Lava.user.MyChildClass'</span>,\n{\n    Extends: <span class=\"hljs-string\">\"Lava.user.MyParentClass\"</span>,\n\n    <span class=\"hljs-comment\">// static constructor</span>\n    init: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(init_arguments)</span> {</span>\n\n        <span class=\"hljs-comment\">// apply some decision logic and choose the new constructor name:</span>\n\n        <span class=\"hljs-comment\">// replace with a method from this class</span>\n        <span class=\"hljs-keyword\">var</span> new_init_name = <span class=\"hljs-string\">\"init_Normal\"</span>;\n        <span class=\"hljs-keyword\">var</span> new_init_name = <span class=\"hljs-string\">\"init_WithBrowserFix\"</span>;\n        <span class=\"hljs-comment\">// or remove the method completely (replace with parent's constructor)</span>\n        <span class=\"hljs-keyword\">var</span> new_init_name = <span class=\"hljs-string\">\"MyParentClass$init\"</span>;\n\n        <span class=\"hljs-comment\">// do your static constructor tasks here</span>\n\n        <span class=\"hljs-comment\">// call the new init method before it's renamed</span>\n        <span class=\"hljs-keyword\">this</span>[new_init_name](init_arguments);\n\n        <span class=\"hljs-comment\">// rename this method in prototype</span>\n        <span class=\"hljs-keyword\">var</span> exact_name = Lava.ClassManager.patch(\n            <span class=\"hljs-comment\">// must always be \"this\"</span>\n            <span class=\"hljs-keyword\">this</span>,\n            <span class=\"hljs-comment\">// Must always be the name of CURRENT class, which you pass to Lava.define above</span>\n            <span class=\"hljs-string\">\"MyChildClass\"</span>,\n            <span class=\"hljs-comment\">// method to replace</span>\n            <span class=\"hljs-string\">\"init\"</span>,\n            <span class=\"hljs-comment\">// name of the new method</span>\n            new_init_name\n        );\n\n        <span class=\"hljs-comment\">// exact_name is name of the method that was replaced</span>\n\n    },\n\n    <span class=\"hljs-comment\">// this is real constructor</span>\n    init_Normal: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(init_arguments)</span> {</span>\n\n        <span class=\"hljs-keyword\">this</span>.MyParentClass$init(init_arguments);\n\n    },\n\n    <span class=\"hljs-comment\">// example of another constructor</span>\n    init_WithBrowserFix: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(init_arguments)</span> {</span>\n\n        <span class=\"hljs-comment\">// do something in addition to init_Normal</span>\n\n        <span class=\"hljs-keyword\">this</span>.init_Normal(init_arguments);\n\n    }\n\n});</pre></div></div></div><p>How this works:</p>\n<div class=\"lava-new-code-container lava-new-code-container-primary\"><div class=\"lava-new-code-box\"><pre class=\"lava-new-code-line-numbers\">&nbsp;&nbsp;1\r\n</pre><div class=\"lava-new-code-overlays\"><pre class=\"lava-new-code-content hljs javascript\">Lava.ClassManager.patch(<span class=\"hljs-keyword\">this</span>, <span class=\"hljs-string\">\"MyChildClass\"</span>, <span class=\"hljs-string\">\"init\"</span>, new_init_name);</pre></div></div></div><p>This line replaces the <code>init</code> that belongs to <code>MyChildClass</code> with another method. \nIt can be any method that belongs to the class, like <code>init_Normal</code> or <code>init_WithBrowserFix</code> (notice how the second calls the first one).\nOr you can totally remove current <code>init</code> by replacing it with parent&#39;s version: &quot;MyParentClass$init&quot;.</p>\n<p>Method is replaced in prototype - this way it will be called only once for each class in inheritance chain,\nwhen the first instance of that class is constructed. For example, if you inherit \n<code>MyGrandChildClass</code> from <code>MyChildClass</code>, then static constructor will be called for both classes:</p>\n<div class=\"lava-new-code-container lava-new-code-container-primary\"><div class=\"lava-new-code-box\"><pre class=\"lava-new-code-line-numbers\">&nbsp;&nbsp;1\r\n2\r\n3\r\n4\r\n</pre><div class=\"lava-new-code-overlays\"><pre class=\"lava-new-code-content hljs javascript\"><span class=\"hljs-comment\">// each class has it's own prototype with `init` from `MyChildClass`</span>\n<span class=\"hljs-comment\">// so here it will be called twice (if this is the first created instance)</span>\n<span class=\"hljs-keyword\">new</span> Lava.user.MyChildClass();\n<span class=\"hljs-keyword\">new</span> Lava.user.MyGrandChildClass();</pre></div></div></div><p>Method which was used for replacing is assigned <span class=\"api-keyword\">null</span>, so after you call</p>\n<div class=\"lava-new-code-container lava-new-code-container-primary\"><div class=\"lava-new-code-box\"><pre class=\"lava-new-code-line-numbers\">&nbsp;&nbsp;1\r\n</pre><div class=\"lava-new-code-overlays\"><pre class=\"lava-new-code-content hljs javascript\">Lava.ClassManager.patch(<span class=\"hljs-keyword\">this</span>, <span class=\"hljs-string\">\"MyChildClass\"</span>, <span class=\"hljs-string\">\"init\"</span>, <span class=\"hljs-string\">\"MyParentClass$init\"</span>);</pre></div></div></div><p>Then reference to the current <code>init</code> method will be lost, \nand <code>this.Class.constructor.prototype.MyParentClass$init</code> will become <span class=\"api-keyword\">null</span>.</p>\n<p>There are certain limitations to using <code>patch</code>:</p>\n<ol>\n<li>The class may patch only itself, and never it&#39;s child or parent classes. \nIn other words, replaced method must belong to current class.</li>\n<li><code>init</code> method can not be removed for the root (bottom) classes, cause generated constructor still calls it.</li>\n<li>Current system allows you to replace a method only once. You can not swap them multiple times.</li>\n</ol>\n<h2 id=\"patching-methods\">Patching methods</h2>\n<p>This is simplified version of framework&#39;s <code>TextInputElement</code> container:</p>\n<div class=\"lava-new-code-container lava-new-code-container-primary\"><div class=\"lava-new-code-box\"><pre class=\"lava-new-code-line-numbers\">&nbsp;&nbsp;1\r\n2\r\n3\r\n4\r\n5\r\n6\r\n7\r\n8\r\n9\r\n10\r\n11\r\n12\r\n13\r\n14\r\n15\r\n16\r\n17\r\n18\r\n19\r\n20\r\n21\r\n22\r\n23\r\n24\r\n25\r\n26\r\n27\r\n28\r\n29\r\n30\r\n31\r\n</pre><div class=\"lava-new-code-overlays\"><pre class=\"lava-new-code-content hljs javascript\">Lava.define(\n<span class=\"hljs-string\">'Lava.view.container.TextInputElement'</span>,\n{\n    Extends: <span class=\"hljs-string\">\"Lava.view.container.Element\"</span>,\n\n    init: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(view, config, widget)</span> {</span>\n\n        <span class=\"hljs-keyword\">var</span> needs_shim = <span class=\"hljs-literal\">true</span>;\n\n        Lava.ClassManager.patch(<span class=\"hljs-keyword\">this</span>, <span class=\"hljs-string\">\"TextInputElement\"</span>, <span class=\"hljs-string\">\"informInDOM\"</span>, needs_shim ? <span class=\"hljs-string\">\"informInDOM_OldIE\"</span> : <span class=\"hljs-string\">\"Element$informInDOM\"</span>);\n\n        <span class=\"hljs-keyword\">this</span>.Element$init(view, config, widget);\n        Lava.ClassManager.patch(<span class=\"hljs-keyword\">this</span>, <span class=\"hljs-string\">\"TextInputElement\"</span>, <span class=\"hljs-string\">\"init\"</span>, <span class=\"hljs-string\">\"Element$init\"</span>);\n\n    },\n\n    <span class=\"hljs-comment\">// Dummy method, which will be replaced in static constructor</span>\n    informInDOM: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> {</span>\n\n        Lava.t();\n\n    },\n\n    informInDOM_OldIE: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> {</span>\n\n        <span class=\"hljs-comment\">// we have our own `informInDOM`, so parent's method exists</span>\n        <span class=\"hljs-keyword\">this</span>.Element$informInDOM();\n        <span class=\"hljs-comment\">// ... apply fixes here ...</span>\n\n    }\n});</pre></div></div></div><p>Here we replace local <code>informInDOM</code> with another method with browser fixes - <code>informInDOM_OldIE</code>, \nor we remove it completely by replacing with parent&#39;s method - <code>Element$informInDOM</code>.</p>\n<p>We need dummy <code>informInDOM</code> to rename parent&#39;s method to <code>Element$informInDOM</code> - this allows us to call it \nfrom <code>informInDOM_OldIE</code> and to use it for replacing.</p>\n<h2 id=\"direct-replacement\">Direct replacement</h2>\n<p>Naturally, you can replace methods in class instance directly, and you don&#39;t need to patch prototypes for that:</p>\n<div class=\"lava-new-code-container lava-new-code-container-primary\"><div class=\"lava-new-code-box\"><pre class=\"lava-new-code-line-numbers\">&nbsp;&nbsp;1\r\n2\r\n3\r\n4\r\n5\r\n6\r\n7\r\n8\r\n9\r\n10\r\n11\r\n12\r\n13\r\n14\r\n15\r\n16\r\n17\r\n18\r\n19\r\n20\r\n21\r\n22\r\n23\r\n24\r\n25\r\n26\r\n27\r\n28\r\n29\r\n30\r\n31\r\n32\r\n33\r\n34\r\n35\r\n36\r\n37\r\n38\r\n39\r\n40\r\n41\r\n42\r\n43\r\n44\r\n45\r\n46\r\n47\r\n48\r\n49\r\n50\r\n</pre><div class=\"lava-new-code-overlays\"><pre class=\"lava-new-code-content hljs javascript\">Lava.define(\n<span class=\"hljs-string\">'Lava.user.MyClass'</span>,\n{\n\n    init: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(config)</span> {</span>\n\n        <span class=\"hljs-keyword\">this</span>.getWay = config.use_alternative_methods \n            ? <span class=\"hljs-keyword\">this</span>.getWay_Alternative\n            : <span class=\"hljs-keyword\">this</span>.getWay_Normal;\n\n    },\n\n    <span class=\"hljs-comment\">// default method that will be replaced in constructor</span>\n    getWay: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> {</span>\n\n        Lava.t();\n\n    },\n\n    getWay_Normal: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> {</span>\n\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"Way of the sword\"</span>;\n\n    },\n\n    getWay_Alternative: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> {</span>\n\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"Way of the gun\"</span>;\n\n    },\n\n    switchMethod: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> {</span>\n\n        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>.getWay == <span class=\"hljs-keyword\">this</span>.getWay_Alternative) {\n\n            <span class=\"hljs-keyword\">this</span>.getWay = <span class=\"hljs-keyword\">this</span>.getWay_Normal;\n\n        } <span class=\"hljs-keyword\">else</span> {\n\n            <span class=\"hljs-keyword\">this</span>.getWay = <span class=\"hljs-keyword\">this</span>.getWay_Alternative;\n\n        }\n\n    }\n\n});\n\n<span class=\"hljs-keyword\">var</span> instance = <span class=\"hljs-keyword\">new</span> Lava.user.MyClass({});\ninstance.switchMethod();\ninstance.getWay(); <span class=\"hljs-comment\">// returns \"Way of the gun\"</span></pre></div></div></div><p>As you see, you can swap methods in class instance freely. And this example supports inheritance:\nyou can define a new class, which inherits from <span class=\"api-string\">&quot;Lava.user.MyClass&quot;</span>, override <code>getWay_Normal</code> and\n<code>getWay_Alternative</code> methods, and it will work as expected.</p>\n"],
	container: {
		type: "Element",
		tag_name: "div"
	}
}