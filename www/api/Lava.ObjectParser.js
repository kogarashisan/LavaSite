{"description":"<p>Currently, the only purpose of this parser is to validate serialized JS types.\nIf parse() does not throw an error - then the argument can be safely eval()&#39;ed.</p>\n<p>Example usage:</p>\n<div class=\"lava-new-code-container lava-new-code-container-primary\"><div class=\"lava-new-code-box\"><pre class=\"lava-new-code-line-numbers\">&nbsp;&nbsp;1\r\n2\r\n3\r\n4\r\n5\r\n6\r\n7\r\n</pre><div class=\"lava-new-code-overlays\"><pre class=\"lava-new-code-content hljs javascript\"><span class=\"hljs-comment\">// from Lava source code:</span>\nLava.parseOptions = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(serialized_object)</span> {</span>\n    Lava.schema.VALIDATE_OPTIONS &amp;&amp; <span class=\"hljs-keyword\">this</span>.ObjectParser.parse(serialized_object);\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">eval</span>(<span class=\"hljs-string\">'('</span> + serialized_object + <span class=\"hljs-string\">')'</span>);\n}\n\n<span class=\"hljs-keyword\">var</span> result = Lava.parseOptions(<span class=\"hljs-string\">'{test1: true, test2: [1,2,3]}'</span>);</pre></div></div></div><p>Permitted serialized values:</p>\n<ul>\n<li>object</li>\n<li>array</li>\n<li>string</li>\n<li>number</li>\n<li>literals (<span class=\"api-keyword\">true</span>, <span class=\"api-keyword\">false</span>, <span class=\"api-keyword\">null</span>, <span class=\"api-keyword\">undefined</span>)</li>\n</ul>\n<p>Objects does not need to be a valid JSON. Any combination of the above types is permitted (like array of objects with arbitrary structure).</p>\n<h2 id=\"usage-by-framework\">Usage by framework</h2>\n<p><a href=\"/www/doc.html#object=Lava;member=parseOptions\">Lava#parseOptions</a> is used every time when framework needs to parse JavaScript objects from templates.\nFor example, in &lt;options&gt; and &lt;properties&gt; directives.</p>\n<p>You can disable these checks by turning off <a href=\"/www/doc.html#object=Lava.schema;member=VALIDATE_OPTIONS\">schema#VALIDATE_OPTIONS</a> switch (may be useful in production environment).</p>\n<h2 id=\"external-paths\">External paths</h2>\n<p>ObjectParser allows external paths in objects, but keep in mind:\nall configs must be serializable, so you must not create circular references or link to constructed objects with prototype.</p>\n<p>Example:</p>\n<div class=\"lava-new-code-container lava-new-code-container-primary\"><div class=\"lava-new-code-box\"><pre class=\"lava-new-code-line-numbers\">&nbsp;&nbsp;1\r\n2\r\n3\r\n4\r\n</pre><div class=\"lava-new-code-overlays\"><pre class=\"lava-new-code-content hljs javascript\">Lava.ObjectParser.parse(\n    <span class=\"hljs-comment\">// parser does not check path existence, only validity</span>\n    <span class=\"hljs-string\">'{external_object: Lava.user.MY_OBJECT}'</span>\n);</pre></div></div></div><p>Currently, list of allowed root namespaces is hardcoded in <code>Lava.ObjectParser.yy.valid_globals</code>.</p>\n","member_chain":[{"descriptors":[{"name":"yy.valid_globals","is_private":false,"type":"member","default_value":"<span class=\"api-highlight-gray\">[ ... ]</span>","description":"<p>Additional globals may be added to the white list</p>\n"}]}],"method_chain":[{"descriptors":[{"name":"parse","is_private":false,"type":"function","params":[{"name":"input","type_names":["string"]}],"param_names_string":"input","description":"<p>If parsing succeeds, then input represents a valid JavaScript object or literal and can be safely eval()&#39;ed</p>\n"}]}]}