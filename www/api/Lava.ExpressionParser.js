{"description":"<h2 id=\"using-parsewithtail-\">Using parseWithTail()</h2>\n<p>This method is used internally when framework needs to parse expressions, followed by some other text\n(for example, when parsing <i>targets</i>). Method stops parsing when it finds the first unmatched closing brace:</p>\n<div class=\"lava-new-code-container lava-new-code-container-primary\"><div class=\"lava-new-code-box\"><pre class=\"lava-new-code-line-numbers\">&nbsp;&nbsp;1\r\n2\r\n3\r\n4\r\n5\r\n</pre><div class=\"lava-new-code-overlays\"><pre class=\"lava-new-code-content hljs javascript\"><span class=\"hljs-keyword\">var</span> config_ref = {\n    input: <span class=\"hljs-string\">\"1 + count) !@#$%^&amp; some text\"</span>,\n    tail_length: <span class=\"hljs-number\">0</span>\n};\n<span class=\"hljs-keyword\">var</span> result = Lava.ExpressionParser.parseWithTail(config_ref);</pre></div></div></div><p>Method will exit when it encounters the closing brace (&quot;)&quot;), and store length of unparsed content in <code>config_ref.tail_length</code> \n(in this case 18). Result is an array of <a href=\"/www/doc.html#class=Lava.scope.Argument\">Lava.scope.Argument</a> configs.</p>\n<p>Another example:</p>\n<div class=\"lava-new-code-container lava-new-code-container-primary\"><div class=\"lava-new-code-box\"><pre class=\"lava-new-code-line-numbers\">&nbsp;&nbsp;1\r\n2\r\n3\r\n4\r\n5\r\n</pre><div class=\"lava-new-code-overlays\"><pre class=\"lava-new-code-content hljs javascript\"><span class=\"hljs-keyword\">var</span> config_ref = {\n    input: <span class=\"hljs-string\">\"i, (1 + count) * 2) !@#$%^&amp; some text\"</span>,\n    tail_length: <span class=\"hljs-number\">0</span>\n};\n<span class=\"hljs-keyword\">var</span> result = Lava.ExpressionParser.parseWithTail(config_ref, Lava.ExpressionParser.SEPARATORS.COMMA);</pre></div></div></div><p>This will generate an array with two configs. Everything after the second closing brace will not be parsed\n(<span class=\"api-string\">&quot;) !@#$%^&amp; some text&quot;</span>).</p>\n","member_chain":[{"descriptors":[{"name":"SEPARATORS","is_private":false,"type":"member","default_value":"<span class=\"api-highlight-gray\">{ ... }</span>","type_names":["number"],"description":"<p>Allowed separators between expressions</p>\n"}]}],"method_chain":[{"descriptors":[{"name":"parse","is_private":false,"type":"function","params":[{"name":"input","description":"<p>Source code</p>\n","type_names":["string"]},{"name":"separator","description":"<p>Allowed separator, when parsing multiple expressions</p>\n","is_optional":true,"type_names":["Lava.ExpressionParser.SEPARATORS"]}],"param_names_string":"input, separator","returns":{"type_names":["Array.&lt;<a href=\"/www/doc.html#object=Support;member=_cArgument\">_cArgument</a>&gt;"]},"description":"<p>Parse expressions</p>\n"},{"name":"parseRaw","is_private":false,"type":"function","params":[{"name":"input","description":"<p>Expression source</p>\n","type_names":["string"]},{"name":"separator","description":"<p>Allowed separator, when parsing multiple expressions</p>\n","is_optional":true,"type_names":["Lava.ExpressionParser.SEPARATORS"]}],"param_names_string":"input, separator","returns":{"type_names":["Array.&lt;<a href=\"/www/doc.html#object=Support;member=_cRawArgument\">_cRawArgument</a>&gt;"]},"description":"<p>Parse expressions, but do not create evaluator functions from their source code</p>\n"},{"name":"parseScopeEval","is_private":false,"type":"function","params":[{"name":"input","description":"<p>Expression source</p>\n","type_names":["string"]}],"param_names_string":"input","returns":{"type_names":["<a href=\"/www/doc.html#object=Support;member=_cScopeLocator\">_cScopeLocator</a>"]},"description":"<p>Parse expression which represents a single path,\nlike <span class=\"api-string\">&quot;$my_widget.something.otherthing&quot;</span> or <span class=\"api-string\">&quot;$my_widget.something[name]&quot;</span></p>\n"},{"name":"parseWithTail","is_private":false,"type":"function","params":[{"name":"config_ref","type_names":["Object"]},{"name":"separator","type_names":["Lava.ExpressionParser.SEPARATORS"]}],"param_names_string":"config_ref, separator","returns":{"type_names":["Array.&lt;<a href=\"/www/doc.html#object=Support;member=_cArgument\">_cArgument</a>&gt;"]},"description":"<p>Parse expressions, which are followed by a closing brace (and anything after it).\nStores the length of unparsed content in <code>config_ref.tail_length</code></p>\n"},{"name":"parseWithTailRaw","is_private":false,"type":"function","params":[{"name":"config_ref","type_names":["Object"]},{"name":"separator","type_names":["Lava.ExpressionParser.SEPARATORS"]}],"param_names_string":"config_ref, separator","returns":{"type_names":["Array.&lt;<a href=\"/www/doc.html#object=Support;member=_cRawArgument\">_cRawArgument</a>&gt;"]},"description":"<p>Same as <a href=\"/www/doc.html#object=Lava.ExpressionParser;member=parseWithTail\">ExpressionParser#parseWithTail</a>, but does not create evaluator functions from source</p>\n"}]}]}