<lavabuild:title>Expressions overview</lavabuild:title>

#Argument and ExpressionParser

{@link Lava.scope.Argument} class evaluates expressions and {@link Lava.ExpressionParser} creates 
{@link _cArgument|configs} for Argument class.

Each Argument instance requires an `evaluator` - a JavaScript function, which is executed in context of the instance
and returns the Expression result. Let's see an example:

<script type="lavabuild/source_result">
Lava.ExpressionParser.parse("count + 1 + $my_widget.my_modifier()")
</script>

This expression uses a variable from view hierarchy - `count`, and a widget modifier `my_modifier`.
Before evaluating the expression, Argument instance needs to create a {@link Lava.scope.PropertyBinding} to `count`,
which is put into `this._binds[0]`. Also it finds `$my_widget` to call modifiers from it (`this._callModifier("0", [])`).
This is done in constructor.

Once again, `evaluator` is a function, generated by ExpressionParser, which is called in context of Argument instance.
This way `this._binds[0].getValue()` returns value of `count` variable. See the Argument class source for better understanding.

<b>You must never write Argument configs by hands - always use ExpressionParser to do that job.</b>
Once again: it's wrong to insert already parsed expressions in your source code. The reason for it: 
author of LiquidLava could decide to change the format of configs or rename Argument internal variables.
If that happens - all your parsed configs will become invalid.
If you want to speed up parsing - then you should do it on server.

##Using ExpressionParser

ExpressionParser rewrites source of expressions into evaluator functions:
- it replaces evaluation of variables with calls to `this._binds[...].getValue()`. 
At the same time, it stores config for that binding in {@link _cArgumentCommon#binds}
- calls to global modifiers are replaced with `this._callGlobalModifier`
- widget modifier calls are replaced with `this._callModifier`, 
and {@link _cModifier} config is added to {@link _cArgumentCommon#modifiers}

It also unescapes operators, for example: "&amp;amp;&amp;amp;" will become "&amp;&amp;". 
All other content is inserted into evaluator as-is.

Expressions must not contain operators with side-effects (operators, which modify their operands), like increment
or assignment operator. Also, there must be no <kw>var</kw> declarations and language constructs, like <kw>if</kw> or <kw>switch</kw>.
Keep in mind, that parser does not check JavaScript validity! 
(it's possible to write expressions, which will compile into invalid evaluator functions)

Tip: if ternary operator is part of another expression - it's recommended to surround it with braces.
If expressions are parts of ternary operator - it's also recommended to enclose them in braces: 
`((...) ? (...) : (...))`. This has nothing to do with ExpressionParser, but is due to low priority of ternary operator 
in JavaScript language. If you forget the braces, then JavaScript engine will place them for you, 
sometimes not the way you want. Such cases are usually hard to find and debug.

 Allowed operands:
- string and number literals
- arrays
- JavaScript keywords: <kw>null</kw>, <kw>undefined</kw>, <kw>true</kw> and <kw>false</kw>
- variable evaluations, like `$my_widget~1.property1.property2`

Inline objects are not allowed in expressions, but you can return them from modifiers or widget properties.
Arrays can contain expressions and other arrays, for example:
```text
$my_widget.my_modifier([1, "test", $myWidget.get_operand()])
```

Some identifiers are rewritten into JavaScript operands:

<table class="api-member-table">
<thead><tr><td>Sequence</td><td>Equivalent</td></tr></thead>
<tbody>
<tr><td>lt</td><td>&lt;</td></tr>
<tr><td>gt</td><td>&gt;</td></tr>
<tr><td>amp</td><td>&amp;</td></tr>
</tbody>
</table>

This way `a lt b` is equivalent to `a < b`.

##Argument config flags

Argument config has {@link _cArgumentCommon#flags} property, which describes the expression. 
See the link for better understanding.